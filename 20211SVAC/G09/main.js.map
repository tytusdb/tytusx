{"version":3,"sources":["./src/app/services/compilador.service.ts","fs (ignored)","path (ignored)","./src/Backend/build/Xpath/ControlError.js","stream (ignored)","./src/Backend/build/Reportes/NodoReporteGramatica.js","./src/Backend/src_backend/index.ts","./src/Backend/build/Xml/XmlResultado.js","./src/Backend/build/Xpath/NodoControlError.js","./src/environments/environment.ts","./src/app/components/arbol-ast/arbol-ast.component.ts","./src/app/components/arbol-ast/arbol-ast.component.html","./src/app/components/tabla-errores/tabla-errores.component.ts","./src/app/components/tabla-errores/tabla-errores.component.html","./src/Backend/build/Xml/EtiquetaDoble.js","./src/Backend/build/Xpath/OpBinaria.js","./src/Backend/build/Xml/Atributo.js","./src/Backend/build/Xml/Tabla.js","./src/Backend/build/Grammar/xmlD.js","./src/Backend/build/Xpath/Primitivo.js","./src/Backend/build/Grammar/xmlA.js","./src/Backend/build/Xpath/TipoSeleccion.js","./src/Backend/build/Xml/Tipos.js","./src/Backend/build/Grammar/xpathA.js","./src/app/app.component.ts","./src/app/app.component.html","./src/Backend/build/Xml/EtiquetaSimple.js","./src/app/components/editor/editor.component.ts","./src/app/components/editor/editor.component.html","./src/Backend/build/Xpath/TiposOp.js","./src/Backend/build/Grammar/xpathD.js","./src/app/app.module.ts","./src/Backend/build/Xpath/TipoVal.js","./src/app/components/tabla-simbolos/tabla-simbolos.component.html","./src/app/components/tabla-simbolos/tabla-simbolos.component.ts","./src/Backend/build/Xml/Fila.js","./src/Backend/build/Reportes/ReporteGramatica.js","./src/Backend/build/Graficas/Graficas.js","./src/Backend/build/Xml/EtiquetaInicio.js","./src/Backend/build/Grammar/xpathT.js","./src/app/app-routing.module.ts","./src/Backend/build/Grammar/xpathTA.js","./src/main.ts","./$_lazy_route_resource lazy namespace object"],"names":[],"mappings":"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AACjC,uBAAuB,mBAAO,CAAC,mCAAuB;AACtD,wBAAwB,mBAAO,CAAC,oCAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,WAAW,aAAa,aAAa;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,eAAe,aAAa,iBAAiB,kBAAkB,gBAAgB;AAC5H;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1Ma;AACb,8CAA8C,cAAc;AAC5D,oBAAoB,mBAAO,CAAC,yBAAa;AACzC,kBAAkB,mBAAO,CAAC,uBAAW;AACrC,kBAAkB,mBAAO,CAAC,uBAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpGa;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,kCAAsB;AACjD,eAAe,mBAAO,CAAC,oBAAQ;AAC/B,gBAAgB,mBAAO,CAAC,qBAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1Ca;AACb,8CAA8C,cAAc;AAC5D,wBAAwB,mBAAO,CAAC,oCAAwB;AACxD,kBAAkB,mBAAO,CAAC,8BAAkB;AAC5C;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3FA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,eAAe,kCAAkC;AACjD,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mJAAmJ;AACnJ,SAAS;;AAET;AACA;AACA,qBAAqB,+BAA+B;AACpD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB,eAAe,KAAK;AACxE,SAAS,UAAU,EAAE;AACrB,kBAAkB,0BAA0B,EAAE;AAC9C,cAAc;AACd,mBAAmB,2jBAA2jB;AAC9kB,qBAAqB,sQAAsQ;AAC3R;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,mEAAmE,GAAG,SAAS,GAAG,4CAA4C,GAAG,aAAa,GAAG,0BAA0B,eAAe,6CAA6C,IAAI,kFAAkF,mBAAmB,cAAc,GAAG,oEAAoE,GAAG,aAAa,GAAG,YAAY,GAAG,cAAc,eAAe,0BAA0B,IAAI,cAAc,+BAA+B,6CAA6C,oBAAoB,kBAAkB,GAAG,kBAAkB,oBAAoB,cAAc,qDAAqD,2BAA2B,qCAAqC,YAAY,iDAAiD,0BAA0B,IAAI,cAAc;AACx6B,yBAAyB,yBAAyB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,oCAAoC;AACpC;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,WAAW,gBAAgB,GAAG,mBAAO,CAAC,kCAAsB;AAC5D,WAAW,iBAAiB,GAAG,mBAAO,CAAC,mCAAuB;AAC9D,WAAW,iBAAiB,GAAG,mBAAO,CAAC,mCAAuB;AAC9D,WAAW,WAAW,GAAG,mBAAO,CAAC,6BAAiB;AAClD,WAAW,eAAe,GAAG,mBAAO,CAAC,iCAAqB;AAC1D,WAAW,eAAe,GAAG,mBAAO,CAAC,mCAAuB;AAC5D,WAAW,mBAAmB,GAAG,mBAAO,CAAC,0CAA8B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,4DAA4D,EAAE;AAC9D,yBAAyB,eAAe,oCAAoC,kBAAkB,yEAAyE,iBAAiB,+CAA+C,cAAc,6DAA6D;AAClT,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,IAAI,IAAgE;AACpE;AACA;AACA,iCAAiC,0CAA0C;AAC3E;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,WAAI,eAAe,mBAAO,CAAC,aAAM;AAC9D;AACA;AACA,QAAQ,KAA6B,IAAI,4CAAY;AACrD;AACA;AACA;;;;;;;;;;;;;;ACv1Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACXA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,eAAe,kCAAkC;AACjD,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mJAAmJ;AACnJ,SAAS;;AAET;AACA;AACA,qBAAqB,+BAA+B;AACpD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB,eAAe,KAAK;AACxE,SAAS,UAAU,EAAE;AACrB,kBAAkB,0BAA0B,EAAE;AAC9C,cAAc;AACd,mBAAmB,qdAAqd;AACxe,qBAAqB,sQAAsQ;AAC3R;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,mEAAmE,GAAG,SAAS,GAAG,4CAA4C,GAAG,kDAAkD,GAAG,0BAA0B,mBAAmB,yEAAyE,mBAAmB,cAAc,GAAG,oDAAoD,GAAG,kDAAkD,GAAG,YAAY,mBAAmB,+BAA+B,oBAAoB,cAAc,GAAG,sDAAsD,GAAG,iBAAiB,mBAAmB,cAAc,mBAAmB,4CAA4C,qCAAqC,YAAY,qCAAqC,cAAc;AAC9zB,yBAAyB,yBAAyB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,oCAAoC;AACpC;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,WAAW,gBAAgB,GAAG,mBAAO,CAAC,kCAAsB;AAC5D,WAAW,iBAAiB,GAAG,mBAAO,CAAC,mCAAuB;AAC9D,WAAW,iBAAiB,GAAG,mBAAO,CAAC,mCAAuB;AAC9D,WAAW,WAAW,GAAG,mBAAO,CAAC,6BAAiB;AAClD,WAAW,eAAe,GAAG,mBAAO,CAAC,iCAAqB;AAC1D,WAAW,eAAe,GAAG,mBAAO,CAAC,mCAAuB;AAC5D,WAAW,gBAAgB,GAAG,mBAAO,CAAC,oCAAwB;AAC9D,WAAW,mBAAmB,GAAG,mBAAO,CAAC,0CAA8B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,4DAA4D,EAAE;AAC9D,yBAAyB,eAAe,oCAAoC,kBAAkB,wEAAwE,iBAAiB,4CAA4C,cAAc,6DAA6D;AAC9S,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,IAAI,IAAgE;AACpE;AACA;AACA,iCAAiC,0CAA0C;AAC3E;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,WAAI,eAAe,mBAAO,CAAC,aAAM;AAC9D;AACA;AACA,QAAQ,KAA6B,IAAI,4CAAY;AACrD;AACA;AACA;;;;;;;;;;;;;;AC9yBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sEAAsE;;;;;;;;;;;;;ACT1D;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;;;;;;;;;;;;ACT/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,eAAe,kCAAkC;AACjD,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mJAAmJ;AACnJ,SAAS;;AAET;AACA;AACA,qBAAqB,+BAA+B;AACpD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB,eAAe,KAAK;AACxE,SAAS,UAAU,EAAE;AACrB,kBAAkB,0BAA0B,EAAE;AAC9C,cAAc;AACd,mBAAmB,8XAA8X;AACjZ,qBAAqB,oPAAoP;AACzQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,kEAAkE,GAAG,SAAS,GAAG,yBAAyB,kBAAkB,iDAAiD,oCAAoC,kEAAkE,GAAG,0BAA0B,mCAAmC,YAAY,GAAG,uDAAuD,kCAAkC,sBAAsB,IAAI,2BAA2B,sFAAsF,iDAAiD,qBAAqB,2BAA2B,qCAAqC,0DAA0D,sDAAsD,2BAA2B,GAAG,2BAA2B,GAAG,2BAA2B,GAAG,2BAA2B,mBAAmB,mBAAmB,oBAAoB,mBAAmB;AAC/gC,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,oCAAoC;AACpC;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,WAAW,gBAAgB,GAAG,mBAAO,CAAC,oCAAwB;AAC9D,WAAW,YAAY,GAAG,mBAAO,CAAC,gCAAoB;AACtD,WAAW,UAAU,GAAG,mBAAO,CAAC,8BAAkB;AAClD,WAAW,YAAY,GAAG,mBAAO,CAAC,gCAAoB;AACtD,WAAW,UAAU,GAAG,mBAAO,CAAC,8BAAkB;AAClD,WAAW,eAAe,GAAG,mBAAO,CAAC,mCAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yBAAyB,aAAa,qNAAqN;AAC3P,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,IAAI,IAAgE;AACpE;AACA;AACA,iCAAiC,8CAA8C;AAC/E;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,WAAI,eAAe,mBAAO,CAAC,aAAM;AAC9D;AACA;AACA,QAAQ,KAA6B,IAAI,4CAAY;AACrD;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACx0BO,MAAM,YAAY;IALzB;QAME,UAAK,GAAG,UAAU,CAAC;KACpB;;wEAFY,YAAY;4FAAZ,YAAY;QCPzB,2EAA+B;;;;;;;;;;;;;;ACAlB;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,oBAAQ;AAC/B,gBAAgB,mBAAO,CAAC,qBAAS;AACjC,gBAAgB,mBAAO,CAAC,qBAAS;AACjC,mBAAmB,mBAAO,CAAC,kCAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,eAAe,aAAa,iBAAiB,kBAAkB,gBAAgB;AAC5H;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmC;AAER;AAI3B,2BAA2B;AACmB;AAMP;;;;;;;;;IC6BX,0EAA4I;IAAjF,uVAAgC;IACvF,0EAAmB;IAAA,uDAAS;IAAA,4DAAM;IAClC,0EAAyG;IAApG,gTAAoB;IAAgF,4DAAC;IAAA,4DAAM;IACpH,4DAAM;;;IAFiB,0DAAS;IAAT,kFAAS;;;IAoFpB,qEAAuC;IACnC,qEAAI;IAAA,uDAAe;IAAA,4DAAK;IACxB,qEAAI;IAAA,uDAAa;IAAA,4DAAK;IACtB,qEAAI;IAAA,uDAAgC;IAAA,4DAAK;IACzC,qEAAI;IAAA,uDAAgB;IAAA,4DAAK;IACzB,qEAAI;IAAA,wDAAa;IAAA,4DAAK;IACtB,sEAAI;IAAA,wDAAkB;IAAA,4DAAK;IAC/B,4DAAK;;;IANG,0DAAe;IAAf,gFAAe;IACf,0DAAa;IAAb,8EAAa;IACb,0DAAgC;IAAhC,0GAAgC;IAChC,0DAAgB;IAAhB,iFAAgB;IAChB,0DAAa;IAAb,8EAAa;IACb,0DAAkB;IAAlB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A;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB,eAAe,KAAK;AACxE,SAAS,UAAU,EAAE;AACrB,kBAAkB,0BAA0B,EAAE;AAC9C,cAAc;AACd,mBAAmB,igBAAigB;AACphB,qBAAqB,oPAAoP;AACzQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB,mEAAmE,GAAG,SAAS,GAAG,aAAa,GAAG,wBAAwB,kBAAkB,wDAAwD,qCAAqC,kFAAkF,mCAAmC,YAAY,GAAG,YAAY,GAAG,wDAAwD,oDAAoD,8BAA8B,IAAI,mCAAmC,uEAAuE,wBAAwB,qCAAqC,mCAAmC,sDAAsD,YAAY,GAAG,cAAc,GAAG,cAAc,GAAG,cAAc;AAC11B,yBAAyB,+DAA+D;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,oCAAoC;AACpC;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,WAAW,gBAAgB,GAAG,mBAAO,CAAC,oCAAwB;AAC9D,WAAW,YAAY,GAAG,mBAAO,CAAC,gCAAoB;AACtD,WAAW,UAAU,GAAG,mBAAO,CAAC,8BAAkB;AAClD,WAAW,YAAY,GAAG,mBAAO,CAAC,gCAAoB;AACtD,WAAW,UAAU,GAAG,mBAAO,CAAC,8BAAkB;AAClD,WAAW,eAAe,GAAG,mBAAO,CAAC,mCAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yBAAyB,aAAa,qNAAqN;AAC3P,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA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DAAK;QACT,4DAAQ;QACR,yEAAO;QACH,sEAAI;QACA,sEAAI;QAAA,6DAAC;QAAA,4DAAK;QACV,sEAAI;QAAA,6DAAC;QAAA,4DAAK;QACd,4DAAK;QACT,4DAAQ;QACZ,4DAAQ;QACZ,4DAAM;QACN,iEAAI;QACR,4DAAM;QACV,4DAAM;QACV,4DAAM;QACV,4DAAM;QACV,4DAAM;;QA/D+C,2DAAgB;QAAhB,sFAAgB;QA4BhB,2DAAmB;QAAnB,yFAAmB;;;;;;;;;;;;;;AErD3D;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZa;AACb,8CAA8C,cAAc;AAC5D,+BAA+B,mBAAO,CAAC,oCAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uDAAuD;;;;;;;;;;;;;ACtB3C;AACb,8CAA8C,cAAc;AAC5D,mBAAmB,mBAAO,CAAC,kCAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/BA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,eAAe,kCAAkC;AACjD,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mJAAmJ;AACnJ,SAAS;;AAET;AACA;AACA,qBAAqB,+BAA+B;AACpD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW,YAAY,IAAI,WAAW,SAAS;AACvE,cAAc,0BAA0B,EAAE;AAC1C,MAAM;AACN,WAAW,69BAA69B;AACx+B,aAAa,wkBAAwkB;AACrlB;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,SAAS,4EAA4E,EAAE,MAAM,EAAE,iBAAiB,EAAE,mDAAmD,qDAAqD,yBAAyB,4CAA4C,2BAA2B,gBAAgB,gBAAgB,iBAAiB,SAAS,EAAE,SAAS,EAAE,yEAAyE,4BAA4B,2JAA2J,wEAAwE,2GAA2G,gBAAgB,QAAQ,EAAE,iBAAiB,YAAY,yBAAyB,8BAA8B,UAAU,EAAE,oBAAoB,EAAE,UAAU,EAAE,UAAU,EAAE,oBAAoB,EAAE,oBAAoB,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,oBAAoB,EAAE,UAAU,EAAE,iCAAiC,eAAe,kEAAkE,aAAa,wCAAwC,2DAA2D,2BAA2B,4CAA4C,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,QAAQ,eAAe,yGAAyG,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,8BAA8B,iCAAiC,EAAE,2GAA2G,EAAE,2GAA2G,gBAAgB,+FAA+F,EAAE,+FAA+F,EAAE,+FAA+F,EAAE,gGAAgG,EAAE,gGAAgG,EAAE,gGAAgG,0BAA0B,yCAAyC,GAAG,gGAAgG,EAAE,gGAAgG,EAAE,gGAAgG,EAAE,gGAAgG,gBAAgB,WAAW,EAAE,WAAW,EAAE,WAAW,EAAE,WAAW,4CAA4C,WAAW,EAAE,WAAW,EAAE,UAAU,EAAE,UAAU,8PAA8P,WAAW,EAAE,WAAW,EAAE,UAAU,EAAE,UAAU;AAC/1G,iBAAiB,8GAA8G;AAC/H;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+DAA+D;AAC/D;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,qCAAqC;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gEAAgE;AAChE,4BAA4B;AAC5B;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,eAAe,eAAe,GAAG,mBAAO,CAAC,mCAAuB;AAChE,mBAAmB,gBAAgB,GAAG,mBAAO,CAAC,oCAAwB;;AAEtE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iCAAiC;AACjC,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL,qDAAqD;AACrD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL,UAAU,wBAAwB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,W;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,CAAC;AACD;AACA,aAAa,WAAW;AACxB,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,CAAC;;;AAGD,IAAI,IAAgE;AACpE;AACA;AACA,6BAA6B,8CAA8C;AAC3E;AACA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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+DAA+D;AAC/D;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,qCAAqC;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gEAAgE;AAChE,4BAA4B;AAC5B;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,eAAe,eAAe,GAAG,mBAAO,CAAC,mCAAuB;AAChE,mBAAmB,gBAAgB,GAAG,mBAAO,CAAC,oCAAwB;;AAEtE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iCAAiC;AACjC,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL,qDAAqD;AACrD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL,UAAU,wBAAwB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,W;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,CAAC;AACD;AACA,aAAa,WAAW;AACxB,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,CAAC;;;AAGD,IAAI,IAAgE;AACpE;AACA;AACA,6BAA6B,gDAAgD;AAC7E;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,WAAI,eAAe,mBAAO,CAAC,aAAM;AAC1D;AACA;AACA,IAAI,KAA6B,IAAI,4CAAY;AACjD;AACA;AACA,C;;;;;;;;;;;;;;;;;;;AC10B+C;AAGF;AACY;AAEzD,IAAI,qEAAW,CAAC,UAAU,EAAE;IAC1B,oEAAc,EAAE,CAAC;CAClB;AAED,2EAAwB,CAAC,eAAe,CAAC,yDAAS,CAAC;KAChD,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;;;;;;;;;;;;ACXpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,4CAA4C,WAAW;AACvD;AACA;AACA,qC","file":"main.js","sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpClient, HttpHeaders } from \"@angular/common/http\";\nimport { Observable } from \"rxjs\";\nimport { AnalisisD_C, Analisis_C, Analisis_D, Analizar_XML } from './../../Backend/src_backend/index'\nimport { ReporteGramatica } from 'src/Backend/src_backend/Reportes/ReporteGramatica';\n//import { Analizar_XML } from '../Backend/src_backend/index';\n@Injectable({\n  providedIn: 'root'\n})\nexport class CompiladorService {\n  constructor(private http: HttpClient) { }\n\n  analizar(codigo: string , texto_xpath:string) {\n    \n\n\n\n    Analizar_XML(codigo,texto_xpath)\n    var alv = {\n      simbolo: Analizar_XML(codigo,texto_xpath).simbolo,\n      cst:Analizar_XML(codigo,texto_xpath).cst,\n      consulta:Analizar_XML(codigo,texto_xpath).consulta,\n      ReporteGramatica:Analizar_XML(codigo,texto_xpath).ReporteGramatica,\n      Error:Analizar_XML(codigo,texto_xpath).Error,\n      Encoding:Analizar_XML(codigo,texto_xpath).Encoding\n      \n      \n    }\n    return alv\n  }\n\n\n  analizarD(codigo: string , texto_xpath:string) {\n\n\n\n\n    Analisis_D(codigo,texto_xpath)\n    var alv = {\n      simbolo: Analisis_D(codigo,texto_xpath).simbolo,\n      cst:Analisis_D(codigo,texto_xpath).cst,\n      consulta:Analisis_D(codigo,texto_xpath).consulta,\n      ReporteGramatica:Analisis_D(codigo,texto_xpath).ReporteGramatica,\n      Error:Analisis_D(codigo,texto_xpath).Error,\n      Encoding:Analisis_D(codigo,texto_xpath).Encoding\n      \n      \n    }\n    return alv\n  }\n  analizarC(codigo: string , texto_xpath:string) {\n\n\n\n\n    Analisis_C(codigo,texto_xpath)\n    var alv = {\n      simbolo: Analisis_C(codigo,texto_xpath).simbolo,\n      cst:Analisis_C(codigo,texto_xpath).cst,\n      consulta:Analisis_C(codigo,texto_xpath).consulta,\n      ReporteGramatica:Analisis_C(codigo,texto_xpath).ReporteGramatica,\n      Error:Analisis_C(codigo,texto_xpath).Error,\n      Encoding:Analisis_C(codigo,texto_xpath).Encoding\n      \n      \n    }\n    return alv\n  }\n  \n  analizarDC(codigo: string , texto_xpath:string) {\n\n\n\n\n    AnalisisD_C(codigo,texto_xpath)\n    var alv = {\n      simbolo: AnalisisD_C(codigo,texto_xpath).simbolo,\n      cst:AnalisisD_C(codigo,texto_xpath).cst,\n      consulta:AnalisisD_C(codigo,texto_xpath).consulta,\n      ReporteGramatica:AnalisisD_C(codigo,texto_xpath).ReporteGramatica,\n      Error:AnalisisD_C(codigo,texto_xpath).Error,\n      Encoding:AnalisisD_C(codigo,texto_xpath).Encoding\n      \n      \n    }\n    return alv\n  }\n  getAstBase64(ast: any): Observable<any> {\n    const json = { ast: ast }\n    return this.http.post<any>('http://localhost:3000/getAstBase64', json);\n  }\n\n}\n","/* (ignored) */","/* (ignored) */","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst TipoSeleccion_1 = require(\"./TipoSeleccion\");\r\nconst NodoControlError_1 = require(\"./NodoControlError\");\r\nclass ControlError {\r\n    constructor(simbolo, tipo, linea, columna, entorno) {\r\n        console.log(\"adentro\");\r\n        ControlError.ListaE.push(new NodoControlError_1.NodoControlError(simbolo, tipo, linea, columna, entorno));\r\n        console.log(ControlError.ListaE);\r\n    }\r\n    static Agregar(simbolo, tipo, linea, columna, entorno) {\r\n        ControlError.ListaE.push(new NodoControlError_1.NodoControlError(simbolo, tipo, linea, columna, entorno));\r\n    }\r\n}\r\nexports.ControlError = ControlError;\r\nControlError.ListaE = [];\r\nfunction graficar(errores, errorbusqueda = {\r\n    simbolo: \"\",\r\n    tipo: \"\",\r\n    linea: \"\",\r\n    columna: \"\",\r\n}) {\r\n    var text = \"\";\r\n    for (let set of errores) {\r\n        if (set.tipo === TipoSeleccion_1.TipoSeleccion.ERROR_LEXICO) {\r\n            text = text + '\\n' + \"simbolo de error: \" + set.simbolo + \" tipo: error lexico\" + \" \" + set.linea + \" \" + set.columna;\r\n        }\r\n        else if (set.tipo === TipoSeleccion_1.TipoSeleccion.ERROR_SINTACTICO) {\r\n            text = text + '\\n' + \"simbolo de error: \" + set.simbolo + \" tipo: error sintactico\" + \" \" + set.linea + \" \" + set.columna;\r\n        }\r\n    }\r\n    return text;\r\n}\r\nexports.graficar = graficar;\r\n","/* (ignored) */","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass NodoReporteGramatica {\r\n    constructor(produccion, regla_semantica) {\r\n        this.produccion = produccion;\r\n        this.regla_semantica = regla_semantica;\r\n    }\r\n}\r\nexports.NodoReporteGramatica = NodoReporteGramatica;\r\n","\nimport { Fila } from './Xml/Fila';\nimport { XmlResultado } from './Xml/XmlResultado';\n//import { SimbolsReport } from './Reportes/TablaSimbolos'\nimport Parser from '../build/Grammar/xmlA.js'\n\nimport parserXpath from '../build/Grammar/xpathTA.js'\n\nimport parserXpathC from '../build/Grammar/xpathA.js'\n\nimport ParserD from '../build/Grammar/xmlD.js'\nimport { TipoSeleccion } from './Xpath/TipoSeleccion';\nimport parserXpathD from '../build/Grammar/xpathT.js'\nimport parserXpathDC from '../build/Grammar/xpathD.js'\nimport { ReporteGramatica } from '../build/Reportes/ReporteGramatica.js';\nimport { ControlError } from '../build/Xpath/ControlError.js';\nimport { Observable } from 'rxjs';\n\n\n\n\n\nconst port = 3000;\n//const parserXpath = require('./Grammar/xpathA.js');\n\n\n\n\n\n\nexport function Analizar_XML(entrada: string,texto_path:string) {\n\n  // aqui voy a vaciar antes que nada los nuevos simbolos\n  //imbolsReport.aux = \"\";\n\n\n  /**\n   * \n   * const tree:XmlResultado = parser.parse(entrada)\n  const {XmlResultado,errores} = parser.parse(entrada);\n  //const {resXpath, errores} = parserXpath.parse(\"#//videojuego\")\n  const {resXpathD, erroresD}  = parserxpathD.parse(\"#//videojuego@\")\n  console.log(\"Respuesta xpathD:\")\n  console.log(JSON.stringify(resXpathD, null, 2))\n  console.log(\"\\nResultado de busqueda:\")\n  console.log(tree.getAsTable().buscar(resXpathD))\n // console.log(graficar(errores))\n  console.log(graficar(erroresD))\n   * \n   * \n   * */ \n  //console.log(\"suu adentro papasito\")\n \n let Rxpath=\"\";\n \n    \n\n  const tree: XmlResultado =Parser.parse(entrada)\n  \n const resXpath:any = parserXpath.parse(texto_path)\n  // Rxpath+=\"Respuesta xpath:\"\n /*  Rxpath+=resXpath\n  //console.log(\"\\nResultado de busqueda:\")\n  Rxpath+=tree.getAsTable().buscar(resXpath);\n*/\n\nconsole.log(resXpath)\n\n\n\n  /*  aqui termina el llenado de la tabla de simbolos **/\n\nlet res=\"\"\n\n\n\n\nControlError.ListaE.forEach(fila => {\n  //console.log(fila)\n  if (fila.entorno==\"XpathAscendente\"){\n\n\n    res=\"no\"\n  }\n  else  if (fila.entorno==\"XpathDescendente\"){\n\n\n    res=\"no\"\n  }\n  else {\n    res=\"su\"\n\n\n  }\n\n\n\n});\n\n  // console.log(Xpath)\n  //console.log(tree.getCstDotA());\n /// console.log(ControlError.ListaE)\n  //console.log(\"alv\"+ReporteGramatica.Lista)\n  var alv ={\n\n    ReporteGramatica:ReporteGramatica.Lista,\n   cst:tree.getCstDotA(),\n   simbolo: tree.getAsTable().filas,\n   consulta:res,\n   Error:ControlError.ListaE,\n   Encoding:tree.etiquitaInicio.encoding\n   \n\n  }\n\n  ControlError.ListaE = []\n  ReporteGramatica.Lista=[]\n\n  return alv\n\n}\n\n\n\nexport function Analisis_D(entrada: string,texto_path:string) {\n\n  // aqui voy a vaciar antes que nada los nuevos simbolos\n  //imbolsReport.aux = \"\";\n\n\n  /**\n   * \n   * const tree:XmlResultado = parser.parse(entrada)\n  const {XmlResultado,errores} = parser.parse(entrada);\n  //const {resXpath, errores} = parserXpath.parse(\"#//videojuego\")\n  const {resXpathD, erroresD}  = parserxpathD.parse(\"#//videojuego@\")\n  console.log(\"Respuesta xpathD:\")\n  console.log(JSON.stringify(resXpathD, null, 2))\n  console.log(\"\\nResultado de busqueda:\")\n  console.log(tree.getAsTable().buscar(resXpathD))\n // console.log(graficar(errores))\n  console.log(graficar(erroresD))\n   * \n   * \n   * */ \n  //console.log(\"suu adentro papasito\")\n \n let Rxpath=\"\";\n \n\n\n  const tree: XmlResultado =ParserD.parse(entrada)\n\n\n  const alv2=ParserD.parse(entrada)\n  const resXpath:any = parserXpathD.parse(texto_path)\n  // Rxpath+=\"Respuesta xpath:\"\n /*  Rxpath+=resXpath\n  //console.log(\"\\nResultado de busqueda:\")\n  Rxpath+=tree.getAsTable().buscar(resXpath);\n*/\n\nconsole.log(resXpath)\n\n\n\n  /*  aqui termina el llenado de la tabla de simbolos **/\n\nlet res=\"\"\n\n\n\n\nControlError.ListaE.forEach(fila => {\n  //console.log(fila)\n  if (fila.entorno==\"XpathAscendente\"){\n\n\n    res=\"no\"\n  }\n  else  if (fila.entorno==\"XpathDescendente\"){\n\n\n    res=\"no\"\n  }\n  else {\n    res=\"su\"\n\n\n  }\n\n\n\n});\n\n\n  /*  aqui termina el llenado de la tabla de simbolos **/\n\n\n\n\n\n  console.log(tree.getErroresSemanticos())\n  // console.log(Xpath)\n  //console.log(tree.getCstDotA());\n // console.log(ControlError.ListaE)\n  //console.log(\"alv\"+ReporteGramatica.Lista)\n  var alv ={\n\n    ReporteGramatica:ReporteGramatica.Lista,\n   cst:tree.getCstDotD(),\n   simbolo: tree.getAsTable().filas,\n   consulta:res,\n   Error:ControlError.ListaE,\n   Encoding:tree.etiquitaInicio.encoding\n   \n\n  }\n\n  ControlError.ListaE = []\n  ReporteGramatica.Lista=[]\n\n  return alv\n\n}\n\n\n\n\n\nexport function Analisis_C(entrada: string,texto_path:string) {\n\n  // aqui voy a vaciar antes que nada los nuevos simbolos\n  //imbolsReport.aux = \"\";\n\n\n  /**\n   * \n   * const tree:XmlResultado = parser.parse(entrada)\n  const {XmlResultado,errores} = parser.parse(entrada);\n  //const {resXpath, errores} = parserXpath.parse(\"#//videojuego\")\n  const {resXpathD, erroresD}  = parserxpathD.parse(\"#//videojuego@\")\n  console.log(\"Respuesta xpathD:\")\n  console.log(JSON.stringify(resXpathD, null, 2))\n  console.log(\"\\nResultado de busqueda:\")\n  console.log(tree.getAsTable().buscar(resXpathD))\n // console.log(graficar(errores))\n  console.log(graficar(erroresD))\n   * \n   * \n   * */ \n  //console.log(\"suu adentro papasito\")\n \n let Rxpath=\"\";\n \n\n\n  const tree: XmlResultado =Parser.parse(entrada)\n\n\n  const alv2=ParserD.parse(entrada)\n const resXpath:any = parserXpathC.parse(texto_path)\n   Rxpath+=\"Respuesta xpath:\"\n   Rxpath+=resXpath\n  //console.log(\"\\nResultado de busqueda:\")\n  Rxpath+=tree.getAsTable().buscar(resXpath);\n\n\n\n\n\n\n  /*  aqui termina el llenado de la tabla de simbolos **/\n\n\n\n\n\n  console.log(tree.getErroresSemanticos())\n  // console.log(Xpath)\n  //console.log(tree.getCstDotA());\n // console.log(ControlError.ListaE)\n  //console.log(\"alv\"+ReporteGramatica.Lista)\n  var alv ={\n\n    ReporteGramatica:ReporteGramatica.Lista,\n   cst:tree.getCstDotD(),\n   simbolo: tree.getAsTable().filas,\n   consulta:Rxpath,\n   Error:ControlError.ListaE,\n   Encoding:tree.etiquitaInicio.encoding\n   \n\n  }\n\n  ControlError.ListaE = []\n  ReporteGramatica.Lista=[]\n\n  return alv\n\n}\n\n\nexport function AnalisisD_C(entrada: string,texto_path:string) {\n\n  // aqui voy a vaciar antes que nada los nuevos simbolos\n  //imbolsReport.aux = \"\";\n\n\n  /**\n   * \n   * const tree:XmlResultado = parser.parse(entrada)\n  const {XmlResultado,errores} = parser.parse(entrada);\n  //const {resXpath, errores} = parserXpath.parse(\"#//videojuego\")\n  const {resXpathD, erroresD}  = parserxpathD.parse(\"#//videojuego@\")\n  console.log(\"Respuesta xpathD:\")\n  console.log(JSON.stringify(resXpathD, null, 2))\n  console.log(\"\\nResultado de busqueda:\")\n  console.log(tree.getAsTable().buscar(resXpathD))\n // console.log(graficar(errores))\n  console.log(graficar(erroresD))\n   * \n   * \n   * */ \n  //console.log(\"suu adentro papasito\")\n \n let Rxpath=\"\";\n \n\n\n  const tree: XmlResultado =ParserD.parse(entrada)\n\n\n  const alv2=ParserD.parse(entrada)\n const resXpath:any = parserXpathDC.parse(texto_path)\n   Rxpath+=\"Respuesta xpath:\"\n   Rxpath+=resXpath\n  //console.log(\"\\nResultado de busqueda:\")\n  Rxpath+=tree.getAsTable().buscar(resXpath);\n\n\n\n\n\n\n  /*  aqui termina el llenado de la tabla de simbolos **/\n\n\n\n\n\n  console.log(tree.getErroresSemanticos())\n  // console.log(Xpath)\n  //console.log(tree.getCstDotA());\n // console.log(ControlError.ListaE)\n  //console.log(\"alv\"+ReporteGramatica.Lista)\n  var alv ={\n\n    ReporteGramatica:ReporteGramatica.Lista,\n   cst:tree.getCstDotD(),\n   simbolo: tree.getAsTable().filas,\n   consulta:Rxpath,\n   Error:ControlError.ListaE,\n   Encoding:tree.etiquitaInicio.encoding\n   \n\n  }\n\n  ControlError.ListaE = []\n  ReporteGramatica.Lista=[]\n\n  return alv\n\n}\n\n\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Graficas_1 = require(\"../Graficas/Graficas\");\r\nconst Tabla_1 = require(\"./Tabla\");\r\nclass XmlResultado {\r\n    constructor(etiquitaInicio, etiquetasCuerpo) {\r\n        this.etiquitaInicio = etiquitaInicio;\r\n        this.etiquetasCuerpo = etiquetasCuerpo;\r\n    }\r\n    imprimir() {\r\n        let texto = \"\";\r\n        this.etiquetasCuerpo.forEach(etiqueta => {\r\n            texto += etiqueta.imprimir();\r\n        });\r\n        return texto;\r\n    }\r\n    getAsTable() {\r\n        let tabla = new Tabla_1.Tabla();\r\n        this.etiquetasCuerpo.forEach(etiqueta => {\r\n            etiqueta.getAsTable().filas.forEach(fila => {\r\n                tabla.addFila(fila);\r\n            });\r\n        });\r\n        return tabla;\r\n    }\r\n    getErroresSemanticos() {\r\n        let texto = \"\";\r\n        this.etiquetasCuerpo.forEach(etiqueta => {\r\n            texto += etiqueta.getErroresSemanticos();\r\n        });\r\n        return texto;\r\n    }\r\n    getCstDotA() {\r\n        let texto = \"\";\r\n        texto += \"digraph {\\n\";\r\n        texto += Graficas_1.Graficas.defNodo(0, \"XML\");\r\n        texto += Graficas_1.Graficas.getElement(1, \"TAG_CONFIGURACION\", 0);\r\n        texto += this.etiquitaInicio.getCstDotA(1);\r\n        if (this.etiquetasCuerpo.length > 0) {\r\n            let cont = 3;\r\n            for (let etiqueta of this.etiquetasCuerpo) {\r\n                if (cont - 3 != this.etiquetasCuerpo.length - 1) {\r\n                    texto += Graficas_1.Graficas.getElement(cont, \"LISTA_ETIQUETAS\", cont + 1);\r\n                    texto += etiqueta.getCstDotA(cont);\r\n                }\r\n                else {\r\n                    texto += Graficas_1.Graficas.getElement(cont, \"LISTA_ETIQUETAS\", 0);\r\n                    texto += etiqueta.getCstDotA(cont);\r\n                }\r\n                cont += 1;\r\n            }\r\n        }\r\n        texto += \"}\";\r\n        return texto;\r\n    }\r\n    getCstDotD() {\r\n        let texto = \"\";\r\n        texto += \"digraph {\\n\";\r\n        texto += Graficas_1.Graficas.defNodo(0, \"XML\");\r\n        texto += Graficas_1.Graficas.getElement(1, \"TAG_CONFIGURACION\", 0);\r\n        texto += this.etiquitaInicio.getCstDotA(1);\r\n        if (this.etiquetasCuerpo.length > 0) {\r\n            let cont = 3;\r\n            for (let etiqueta of this.etiquetasCuerpo) {\r\n                if (cont === 3) {\r\n                    texto += Graficas_1.Graficas.getElement(cont, \"LISTA_ETIQUETAS\", 0);\r\n                    texto += etiqueta.getCstDotD(cont);\r\n                }\r\n                else {\r\n                    texto += Graficas_1.Graficas.getElement(cont, \"LISTA_ETIQUETAS\", cont - 1);\r\n                    texto += etiqueta.getCstDotD(cont);\r\n                }\r\n                cont += 1;\r\n            }\r\n        }\r\n        texto += \"}\";\r\n        return texto;\r\n    }\r\n}\r\nexports.XmlResultado = XmlResultado;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass NodoControlError {\r\n    constructor(simbolo, tipo, linea, columna, entorno) {\r\n        this.simbolo = simbolo;\r\n        this.tipo = tipo;\r\n        this.linea = linea;\r\n        this.columna = columna;\r\n        this.entorno = entorno;\r\n        //   this.Agregar(this.simbolo,this.tipo,this.linea,this.columna,this.entorno)\r\n    }\r\n}\r\nexports.NodoControlError = NodoControlError;\r\n","// This file can be replaced during build by using the `fileReplacements` array.\r\n// `ng build --prod` replaces `environment.ts` with `environment.prod.ts`.\r\n// The list of file replacements can be found in `angular.json`.\r\n\r\nexport const environment = {\r\n  production: false\r\n};\r\n\r\n/*\r\n * For easier debugging in development mode, you can import the following file\r\n * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.\r\n *\r\n * This import should be commented out in production mode because it will have a negative impact\r\n * on performance if an error is thrown.\r\n */\r\n// import 'zone.js/dist/zone-error';  // Included with Angular CLI.\r\n","import { Component, Input, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-arbol-ast',\n  templateUrl: './arbol-ast.component.html',\n  styleUrls: ['./arbol-ast.component.css']\n})\nexport class ArbolAstComponent implements OnInit {\n\n  @Input() arbolJson:any\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n","<div class=\"row justify-content-center tabla\">\n    <div class=\"col-md-8 tab\">\n        <ul class=\"nav nav-tabs justify-content-center\">\n            <li class=\"nav-item active\">\n                <a class=\"nav-link active\" data-toggle=\"tab\" href=\"#errores\">Arbol Ast</a>\n            </li>\n        </ul>\n    </div>\n    <img src=\"https://media.gettyimages.com/photos/artificial-ingelligence-cpu-empty-landscape-picture-id1132483126?s=2048x2048\">\n</div>\n\n\n<!-- <script src=\"https://d3js.org/d3.v3.min.js\"></script>\n<script src=\"https://vanya.jp.net/vtree/dist/vtree.js\"></script>\n<script>\n  window.onload = () => {\n    var json = `{\"mensaje\":1}`;\n    var vt = new VTree(astDiv);\n    var reader = new VTree.reader.Object();\n    var data = reader.read(JSON.parse(json));\n    vt.data(data).update();\n  };\n</script>\n<div id=\"astDiv\"></div> -->","import { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-tabla-errores',\n  templateUrl: './tabla-errores.component.html',\n  styleUrls: ['./tabla-errores.component.css']\n})\nexport class TablaErroresComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n","<div class=\"row justify-content-center tabla\">\n    <div class=\"col-md-8 tab\">\n        <ul class=\"nav nav-tabs justify-content-center\">\n            <li class=\"nav-item active\">\n                <a class=\"nav-link active\" data-toggle=\"tab\" href=\"#errores\">Tabla de Errores</a>\n            </li>\n        </ul>\n        <div class=\"tab-pane\" id=\"errores\">\n            <div class=\"col-md-12\">\n                <br>\n                <div style=\"width: auto; height: auto;\">\n                    <table class=\"table table-danger table-hover\">\n                        <thead>\n                            <tr>\n                                <td>TIPO</td>\n                                <td>ERROR</td>\n                                <td>FILA</td>\n                                <td>COLUMNA</td>\n                            </tr>\n                        </thead>\n                        <tbody>\n                            <tr>\n                                <td>1</td>\n                                <td>2</td>\n                                <td>3</td>\n                                <td>4</td>\n                            </tr>\n                        </tbody>\n                    </table>\n                </div>\n                <br>\n            </div>\n        </div>\n    </div>\n</div>","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Graficas_1 = require(\"../Graficas/Graficas\");\r\nconst Fila_1 = require(\"./Fila\");\r\nconst Tabla_1 = require(\"./Tabla\");\r\nconst Tipos_1 = require(\"./Tipos\");\r\nconst ControlError_1 = require(\"../Xpath/ControlError\");\r\nconst TipoSeleccion_1 = require(\"../Xpath/TipoSeleccion\");\r\nclass EtiquetaDoble {\r\n    constructor(nombreTagAbre, nombreTagCierre, listaAtributos, cadenaValores, listaHijos, linea, columna, idSent) {\r\n        this.padre = null;\r\n        this.nombreTagAbre = nombreTagAbre;\r\n        this.nombreTagCierre = nombreTagCierre;\r\n        this.listaAtributos = listaAtributos;\r\n        this.tineHijos = listaHijos.length > 0;\r\n        this.cadenaValores = (listaHijos.length == 0) ? cadenaValores : \"\";\r\n        this.listaHijos = (listaHijos.length > 0) ? listaHijos : [];\r\n        this.linea = linea;\r\n        this.columna = columna;\r\n        this.idSent = idSent;\r\n        this.listaAtributos.forEach(atributo => {\r\n            atributo.etiquetaContendora = this;\r\n        });\r\n        this.listaHijos.forEach(hijo => {\r\n            hijo.padre = this;\r\n        });\r\n    }\r\n    imprimir() {\r\n        let texto = \"\";\r\n        texto += \"<\" + this.nombreTagAbre;\r\n        this.listaAtributos.forEach(atributo => {\r\n            texto += \" \" + atributo.imprimir();\r\n        });\r\n        texto += \">\";\r\n        if (this.listaHijos.length > 0) {\r\n            texto += \"\\n\";\r\n        }\r\n        texto += this.cadenaValores;\r\n        this.listaHijos.forEach(hijo => {\r\n            texto += hijo.imprimir();\r\n        });\r\n        texto += \"</\" + this.nombreTagCierre + \"> \\n\";\r\n        return texto;\r\n    }\r\n    getName() {\r\n        return this.nombreTagAbre;\r\n    }\r\n    getAmbito() {\r\n        let listaAmbito = [];\r\n        for (let etiqueta = this.padre; etiqueta != null; etiqueta = etiqueta.padre) {\r\n            listaAmbito.push(etiqueta.getName());\r\n        }\r\n        listaAmbito.push(\"GLOBAL\");\r\n        return listaAmbito;\r\n    }\r\n    getAsTable() {\r\n        let tabla = new Tabla_1.Tabla();\r\n        tabla.addFila(new Fila_1.Fila(this.nombreTagAbre, Tipos_1.Tipos.ETIQUETA_DOBLE, this.getAmbito(), this.linea, this.columna, this.imprimir()));\r\n        this.listaAtributos.forEach(atributo => {\r\n            tabla.addFila(atributo.getAsRowTable());\r\n        });\r\n        this.listaHijos.forEach(etiqueta => {\r\n            etiqueta.getAsTable().filas.forEach(fila => {\r\n                tabla.addFila(fila);\r\n            });\r\n        });\r\n        if (!this.tineHijos) {\r\n            if (this.cadenaValores != \"\") {\r\n                tabla.addFila(new Fila_1.Fila(\"-\", Tipos_1.Tipos.VALOR, [this.getName()].concat(this.getAmbito()), this.linea, this.columna + this.nombreTagAbre.length + 2, this.cadenaValores));\r\n            }\r\n        }\r\n        return tabla;\r\n    }\r\n    getErroresSemanticos() {\r\n        let texto = \"\";\r\n        if (this.nombreTagAbre != this.nombreTagCierre) {\r\n            console.log(\"error arribaa-----------\");\r\n            /*\r\n            \r\n            constructor(simbolo: string, tipo: TipoSeleccion, linea: any, columna: any, entorno: string) {\r\n            */\r\n            texto += `Error(Linea: ${this.linea}, Columna: ${this.columna}): El nombre del tag de apertura no es igual al de cierre.\\n`;\r\n            ControlError_1.ControlError.Agregar(this.nombreTagAbre, TipoSeleccion_1.TipoSeleccion.ERROR_SEMANTICO, this.linea, this.columna, this.padre.getName());\r\n        }\r\n        this.listaAtributos.forEach(atributo => {\r\n            let apariciones = 0;\r\n            for (let atr2 of this.listaAtributos) {\r\n                if (atributo.nombre == atr2.nombre) {\r\n                    apariciones += 1;\r\n                }\r\n                if (apariciones > 1) {\r\n                    console.log(\"error abajo\");\r\n                    texto += `Error(Linea: ${atributo.linea}, Columna: ${atributo.columna}): El atributo '${atributo.nombre}' se encuentra repetido.\\n`;\r\n                    ControlError_1.ControlError.Agregar(atributo.nombre, TipoSeleccion_1.TipoSeleccion.ERROR_SEMANTICO, this.linea, this.columna, this.padre.getName());\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n        this.listaHijos.forEach(hijo => {\r\n            texto += hijo.getErroresSemanticos();\r\n        });\r\n        return texto;\r\n    }\r\n    getCstDotA(idPadre) {\r\n        let texto = \"\";\r\n        texto += Graficas_1.Graficas.getElement(this.idSent, \"ETIQUETA\", idPadre);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 1, \"TAG_APERTURA\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 2, \"AbreTagApertura\", this.idSent + 1);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 3, \"<\" + this.nombreTagAbre, this.idSent + 2);\r\n        if (this.listaAtributos.length > 0) {\r\n            let cont = 4;\r\n            for (let atributo of this.listaAtributos) {\r\n                if (cont - 4 != this.listaAtributos.length - 1) {\r\n                    texto += Graficas_1.Graficas.getElement(this.idSent + cont, \"LISTA_ATRIBUTOS\", this.idSent + cont + 1);\r\n                    texto += atributo.getCstDotA(this.idSent + cont);\r\n                }\r\n                else {\r\n                    texto += Graficas_1.Graficas.getElement(this.idSent + cont, \"LISTA_ATRIBUTOS\", this.idSent + 1);\r\n                    texto += atributo.getCstDotA(this.idSent + cont);\r\n                }\r\n                cont += 1;\r\n            }\r\n        }\r\n        let idSent2 = this.idSent + 4 + this.listaAtributos.length;\r\n        texto += Graficas_1.Graficas.getElement(idSent2 + 1, \"CierreTagApertura\", this.idSent + 1);\r\n        texto += Graficas_1.Graficas.getElement(idSent2 + 2, \">\", idSent2 + 1);\r\n        if (this.listaHijos.length > 0) {\r\n            let cont = 3;\r\n            for (let hijo of this.listaHijos) {\r\n                if (cont - 3 != this.listaHijos.length - 1) {\r\n                    texto += Graficas_1.Graficas.getElement(idSent2 + cont, \"LISTA_ETIQUETAS\", idSent2 + cont + 1);\r\n                    texto += hijo.getCstDotA(idSent2 + cont);\r\n                }\r\n                else {\r\n                    texto += Graficas_1.Graficas.getElement(idSent2 + cont, \"LISTA_ETIQUETAS\", this.idSent);\r\n                    texto += hijo.getCstDotA(idSent2 + cont);\r\n                }\r\n                cont += 1;\r\n            }\r\n        }\r\n        else if (this.cadenaValores != \"\") {\r\n            texto += Graficas_1.Graficas.getElement(idSent2 + 3, \"CadenaValores\", this.idSent);\r\n            texto += Graficas_1.Graficas.getElement(idSent2 + 4, this.cadenaValores, idSent2 + 3);\r\n        }\r\n        let idSent3 = idSent2 + 4 + this.listaHijos.length;\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 1, \"TAG_CIERRE\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 2, \"AbreTagCierre\", idSent3 + 1);\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 3, \"</\" + this.nombreTagCierre, idSent3 + 2);\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 4, \"CierreTagCierre\", idSent3 + 1);\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 5, \">\", idSent3 + 4);\r\n        return texto;\r\n    }\r\n    getCstDotD(idPadre) {\r\n        let texto = \"\";\r\n        texto += Graficas_1.Graficas.getElement(this.idSent, \"ETIQUETA\", idPadre);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 1, \"TAG_APERTURA\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 2, \"AbreTagApertura\", this.idSent + 1);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 3, \"<\" + this.nombreTagAbre, this.idSent + 2);\r\n        if (this.listaAtributos.length > 0) {\r\n            let cont = 4;\r\n            for (let atributo of this.listaAtributos) {\r\n                if (cont === 4) {\r\n                    texto += Graficas_1.Graficas.getElement(this.idSent + cont, \"LISTA_ATRIBUTOS\", this.idSent + 1);\r\n                    texto += atributo.getCstDotA(this.idSent + cont);\r\n                }\r\n                else {\r\n                    texto += Graficas_1.Graficas.getElement(this.idSent + cont, \"LISTA_ATRIBUTOS\", this.idSent + cont - 1);\r\n                    texto += atributo.getCstDotA(this.idSent + cont);\r\n                }\r\n                cont += 1;\r\n            }\r\n        }\r\n        let idSent2 = this.idSent + 4 + this.listaAtributos.length;\r\n        texto += Graficas_1.Graficas.getElement(idSent2 + 1, \"CierreTagApertura\", this.idSent + 1);\r\n        texto += Graficas_1.Graficas.getElement(idSent2 + 2, \">\", idSent2 + 1);\r\n        if (this.listaHijos.length > 0) {\r\n            let cont = 3;\r\n            for (let hijo of this.listaHijos) {\r\n                if (cont === 3) {\r\n                    texto += Graficas_1.Graficas.getElement(idSent2 + cont, \"LISTA_ETIQUETAS\", this.idSent);\r\n                    texto += hijo.getCstDotD(idSent2 + cont);\r\n                }\r\n                else {\r\n                    texto += Graficas_1.Graficas.getElement(idSent2 + cont, \"LISTA_ETIQUETAS\", idSent2 + cont - 1);\r\n                    texto += hijo.getCstDotD(idSent2 + cont);\r\n                }\r\n                cont += 1;\r\n            }\r\n        }\r\n        else if (this.cadenaValores != \"\") {\r\n            texto += Graficas_1.Graficas.getElement(idSent2 + 3, \"CadenaValores\", this.idSent);\r\n            texto += Graficas_1.Graficas.getElement(idSent2 + 4, this.cadenaValores, idSent2 + 3);\r\n        }\r\n        let idSent3 = idSent2 + 4 + this.listaHijos.length;\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 1, \"TAG_CIERRE\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 2, \"AbreTagCierre\", idSent3 + 1);\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 3, \"</\" + this.nombreTagCierre, idSent3 + 2);\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 4, \"CierreTagCierre\", idSent3 + 1);\r\n        texto += Graficas_1.Graficas.getElement(idSent3 + 5, \">\", idSent3 + 4);\r\n        return texto;\r\n    }\r\n}\r\nexports.EtiquetaDoble = EtiquetaDoble;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Primitivo_1 = require(\"./Primitivo\");\r\nconst TiposOp_1 = require(\"./TiposOp\");\r\nconst TipoVal_1 = require(\"./TipoVal\");\r\nclass OpBinaria {\r\n    constructor(opIzq, opDer, tipo) {\r\n        this.opIzq = opIzq;\r\n        this.opDer = opDer;\r\n        this.tipo = tipo;\r\n    }\r\n    ejecutar() {\r\n        let primitivoIzq = this.opIzq.ejecutar();\r\n        let primitivoDer = this.opDer.ejecutar();\r\n        switch (this.tipo) {\r\n            case TiposOp_1.TiposOp.SUMA:\r\n                if ((primitivoIzq.tipo === TipoVal_1.TipoVal.ENTERO || primitivoIzq.tipo === TipoVal_1.TipoVal.DECIMAL) &&\r\n                    (primitivoDer.tipo === TipoVal_1.TipoVal.ENTERO || primitivoDer.tipo === TipoVal_1.TipoVal.DECIMAL)) {\r\n                    let res = primitivoIzq.valor + primitivoDer.valor;\r\n                    let tipo = res % 1 === 0 ? TipoVal_1.TipoVal.ENTERO : TipoVal_1.TipoVal.DECIMAL;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.RESTA:\r\n                if ((primitivoIzq.tipo === TipoVal_1.TipoVal.ENTERO || primitivoIzq.tipo === TipoVal_1.TipoVal.DECIMAL) &&\r\n                    (primitivoDer.tipo === TipoVal_1.TipoVal.ENTERO || primitivoDer.tipo === TipoVal_1.TipoVal.DECIMAL)) {\r\n                    let res = primitivoIzq.valor - primitivoDer.valor;\r\n                    let tipo = res % 1 === 0 ? TipoVal_1.TipoVal.ENTERO : TipoVal_1.TipoVal.DECIMAL;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.MULTIPLICACION:\r\n                if ((primitivoIzq.tipo === TipoVal_1.TipoVal.ENTERO || primitivoIzq.tipo === TipoVal_1.TipoVal.DECIMAL) &&\r\n                    (primitivoDer.tipo === TipoVal_1.TipoVal.ENTERO || primitivoDer.tipo === TipoVal_1.TipoVal.DECIMAL)) {\r\n                    let res = primitivoIzq.valor * primitivoDer.valor;\r\n                    let tipo = res % 1 === 0 ? TipoVal_1.TipoVal.ENTERO : TipoVal_1.TipoVal.DECIMAL;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.DIVISION:\r\n                if ((primitivoIzq.tipo === TipoVal_1.TipoVal.ENTERO || primitivoIzq.tipo === TipoVal_1.TipoVal.DECIMAL) &&\r\n                    (primitivoDer.tipo === TipoVal_1.TipoVal.ENTERO || primitivoDer.tipo === TipoVal_1.TipoVal.DECIMAL)) {\r\n                    let res = primitivoIzq.valor / primitivoDer.valor;\r\n                    let tipo = res % 1 === 0 ? TipoVal_1.TipoVal.ENTERO : TipoVal_1.TipoVal.DECIMAL;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.MODULO:\r\n                if ((primitivoIzq.tipo === TipoVal_1.TipoVal.ENTERO || primitivoIzq.tipo === TipoVal_1.TipoVal.DECIMAL) &&\r\n                    (primitivoDer.tipo === TipoVal_1.TipoVal.ENTERO || primitivoDer.tipo === TipoVal_1.TipoVal.DECIMAL)) {\r\n                    let res = primitivoIzq.valor % primitivoDer.valor;\r\n                    let tipo = res % 1 === 0 ? TipoVal_1.TipoVal.ENTERO : TipoVal_1.TipoVal.DECIMAL;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.AND:\r\n                if (primitivoIzq.tipo === TipoVal_1.TipoVal.BOLEANO && primitivoDer.tipo === TipoVal_1.TipoVal.BOLEANO) {\r\n                    let res = primitivoIzq.valor && primitivoDer.valor;\r\n                    let tipo = TipoVal_1.TipoVal.BOLEANO;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.OR:\r\n                if (primitivoIzq.tipo === TipoVal_1.TipoVal.BOLEANO && primitivoDer.tipo === TipoVal_1.TipoVal.BOLEANO) {\r\n                    let res = primitivoIzq.valor || primitivoDer.valor;\r\n                    let tipo = TipoVal_1.TipoVal.BOLEANO;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.MAYOR_QUE:\r\n                if (primitivoIzq.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA] &&\r\n                    primitivoDer.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA]) {\r\n                    let res = primitivoIzq.valor > primitivoDer.valor;\r\n                    let tipo = TipoVal_1.TipoVal.BOLEANO;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.MENOR_QUE:\r\n                if (primitivoIzq.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA] &&\r\n                    primitivoDer.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA]) {\r\n                    let res = primitivoIzq.valor < primitivoDer.valor;\r\n                    let tipo = TipoVal_1.TipoVal.BOLEANO;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.MAYOR_IGUAL:\r\n                if (primitivoIzq.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA] &&\r\n                    primitivoDer.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA]) {\r\n                    let res = primitivoIzq.valor >= primitivoDer.valor;\r\n                    let tipo = TipoVal_1.TipoVal.BOLEANO;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.MENOR_IGUAL:\r\n                if (primitivoIzq.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA] &&\r\n                    primitivoDer.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA]) {\r\n                    let res = primitivoIzq.valor <= primitivoDer.valor;\r\n                    let tipo = TipoVal_1.TipoVal.BOLEANO;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n            case TiposOp_1.TiposOp.NO_IGUAL:\r\n                if (primitivoIzq.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA] &&\r\n                    primitivoDer.tipo in [TipoVal_1.TipoVal.ENTERO, TipoVal_1.TipoVal.DECIMAL, TipoVal_1.TipoVal.BOLEANO, TipoVal_1.TipoVal.CADENA]) {\r\n                    let res = primitivoIzq.valor != primitivoDer.valor;\r\n                    let tipo = TipoVal_1.TipoVal.BOLEANO;\r\n                    return new Primitivo_1.Primitivo(res, tipo);\r\n                }\r\n        }\r\n    }\r\n}\r\nexports.OpBinaria = OpBinaria;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Graficas_1 = require(\"../Graficas/Graficas\");\r\nconst Fila_1 = require(\"./Fila\");\r\nconst Tipos_1 = require(\"./Tipos\");\r\nclass Atributo {\r\n    constructor(nombre, valor, linea, columna, idSent) {\r\n        this.etiquetaContendora = null;\r\n        this.nombre = nombre;\r\n        this.valor = valor;\r\n        this.linea = linea;\r\n        this.columna = columna;\r\n        this.idSent = idSent;\r\n    }\r\n    getAmbito() {\r\n        let listaAmbito = [];\r\n        for (let etiqueta = this.etiquetaContendora; etiqueta != null; etiqueta = etiqueta.padre) {\r\n            listaAmbito.push(etiqueta.getName());\r\n        }\r\n        listaAmbito.push(\"GLOBAL\");\r\n        return listaAmbito;\r\n    }\r\n    getAsRowTable() {\r\n        return (new Fila_1.Fila(this.nombre, Tipos_1.Tipos.ATRIBUTO, this.getAmbito(), this.linea, this.columna, this.imprimir()));\r\n    }\r\n    imprimir() {\r\n        let texto = \"\";\r\n        texto = this.nombre + \"=\" + this.valor;\r\n        return texto;\r\n    }\r\n    getCstDotA(idPadre) {\r\n        let texto = \"\";\r\n        texto += Graficas_1.Graficas.getElement(this.idSent, \"ATRIBUTO\", idPadre);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 1, \"NombreAtributo\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 2, this.nombre, this.idSent + 1);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 4, \"IgualAtributo\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 5, \"=\", this.idSent + 4);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 6, \"ValorAtributo\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 7, this.valor.split(\"\\\"\").join(\"\"), this.idSent + 6);\r\n        return texto;\r\n    }\r\n}\r\nexports.Atributo = Atributo;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst TipoSeleccion_1 = require(\"../Xpath/TipoSeleccion\");\r\nconst TipoVal_1 = require(\"../Xpath/TipoVal\");\r\nfunction sonAmbitosIguales(ambito1, ambito2) {\r\n    if (ambito1.length === ambito2.length) {\r\n        for (let i = 0; i < ambito1.length; i++) {\r\n            if (ambito1[i] != ambito2[i]) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nfunction esSimboloIgual(elemBusqueda, fila) {\r\n    if (elemBusqueda.nombre == fila.nombre &&\r\n        sonAmbitosIguales(elemBusqueda.listaAmbito, fila.listaAmbito)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nclass Tabla {\r\n    constructor() {\r\n        this.filas = [];\r\n    }\r\n    addFila(fila) {\r\n        this.filas.push(fila);\r\n    }\r\n    buscar(resXpath, elemBusqueda = {\r\n        nombre: \"\",\r\n        tipo: \"\",\r\n        listaAmbito: ['GLOBAL'],\r\n        selector: \"/\",\r\n        inidiceRestringido: false,\r\n        indice: 0\r\n    }) {\r\n        let texto = \"\";\r\n        for (let set of resXpath) {\r\n            if (set.tipo === TipoSeleccion_1.TipoSeleccion.ACCESO_NODO_RAIZ && set.predicado == null) {\r\n                for (let fila of this.filas) {\r\n                    if (fila.nombre === set.id && fila.listaAmbito[0] === 'GLOBAL') {\r\n                        texto += fila.valor;\r\n                    }\r\n                }\r\n            }\r\n            if (set.tipo === TipoSeleccion_1.TipoSeleccion.SELECT_NODOS_FROM_NODO) {\r\n                elemBusqueda.nombre = set.id;\r\n                if (set.selector === \"//\" && elemBusqueda.listaAmbito.length === 1 && set.next == null) {\r\n                    elemBusqueda.selector = \"//\";\r\n                }\r\n                if (set.predicado != null) {\r\n                    let opBinaria = set.predicado;\r\n                    let res = opBinaria.ejecutar();\r\n                    if (res.tipo === TipoVal_1.TipoVal.ENTERO) {\r\n                        elemBusqueda.inidiceRestringido = true;\r\n                        elemBusqueda.indice = res.valor - 1;\r\n                    }\r\n                }\r\n                if (set.next != null) {\r\n                    elemBusqueda.listaAmbito.unshift(set.id);\r\n                    texto += this.buscar([set.next], elemBusqueda);\r\n                }\r\n                else {\r\n                    let cont = 0;\r\n                    for (let fila of this.filas) {\r\n                        if (esSimboloIgual(elemBusqueda, fila) || (elemBusqueda.listaAmbito.length === 1) && elemBusqueda.nombre === fila.nombre) {\r\n                            let condicion = elemBusqueda.inidiceRestringido ? cont === elemBusqueda.indice : true;\r\n                            texto += fila.valor;\r\n                            cont += 1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (set.tipo === TipoSeleccion_1.TipoSeleccion.SELECT_NODOS_FROM_NODO) {\r\n            }\r\n            elemBusqueda = {\r\n                nombre: \"\",\r\n                tipo: \"\",\r\n                listaAmbito: ['GLOBAL'],\r\n                selector: \"/\",\r\n                inidiceRestringido: false,\r\n                indice: 0\r\n            };\r\n            texto += \"\\n\";\r\n        }\r\n        return texto;\r\n    }\r\n}\r\nexports.Tabla = Tabla;\r\n","/* parser generated by jison 0.4.18 */\r\n/*\r\n  Returns a Parser object of the following structure:\r\n\r\n  Parser: {\r\n    yy: {}\r\n  }\r\n\r\n  Parser.prototype: {\r\n    yy: {},\r\n    trace: function(),\r\n    symbols_: {associative list: name ==> number},\r\n    terminals_: {associative list: number ==> name},\r\n    productions_: [...],\r\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\r\n    table: [...],\r\n    defaultActions: {...},\r\n    parseError: function(str, hash),\r\n    parse: function(input),\r\n\r\n    lexer: {\r\n        EOF: 1,\r\n        parseError: function(str, hash),\r\n        setInput: function(input),\r\n        input: function(),\r\n        unput: function(str),\r\n        more: function(),\r\n        less: function(n),\r\n        pastInput: function(),\r\n        upcomingInput: function(),\r\n        showPosition: function(),\r\n        test_match: function(regex_match_array, rule_index),\r\n        next: function(),\r\n        lex: function(),\r\n        begin: function(condition),\r\n        popState: function(),\r\n        _currentRules: function(),\r\n        topState: function(),\r\n        pushState: function(condition),\r\n\r\n        options: {\r\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\r\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\r\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\r\n        },\r\n\r\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\r\n        rules: [...],\r\n        conditions: {associative list: name ==> set},\r\n    }\r\n  }\r\n\r\n\r\n  token location info (@$, _$, etc.): {\r\n    first_line: n,\r\n    last_line: n,\r\n    first_column: n,\r\n    last_column: n,\r\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\r\n  }\r\n\r\n\r\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\r\n    text:        (matched text)\r\n    token:       (the produced terminal token, if any)\r\n    line:        (yylineno)\r\n  }\r\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\r\n    loc:         (yylloc)\r\n    expected:    (string describing the set of expected tokens)\r\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\r\n  }\r\n*/\r\nvar xmlD = (function () {\r\n    var o = function (k, v, o, l) { for (o = o || {}, l = k.length; l--; o[k[l]] = v)\r\n        ; return o; }, $V0 = [1, 8], $V1 = [1, 9], $V2 = [1, 14], $V3 = [6, 19], $V4 = [2, 5], $V5 = [1, 21], $V6 = [2, 6, 12, 19], $V7 = [14, 22, 24], $V8 = [2, 24], $V9 = [2, 12, 16, 19], $Va = [2, 12];\r\n    var parser = { trace: function trace() { },\r\n        yy: {},\r\n        symbols_: { \"error\": 2, \"XML\": 3, \"TAG_CONFIGURACION\": 4, \"LISTA_ETIQUETAS\": 5, \"EOF\": 6, \"ETIQUETA\": 7, \"ListaEtiqueta\": 8, \"TAG_APERTURA\": 9, \"MenuEtiqueta\": 10, \"TAG_UNICO\": 11, \"AbreTagApertura\": 12, \"DELIMITADOR\": 13, \"CierreTagApertura\": 14, \"TAG_CIERRE\": 15, \"CadenaValores\": 16, \"MENU_TAG_APERTURA\": 17, \"LISTA_ATRIBUTOS\": 18, \"AbreTagCierre\": 19, \"CierreTagCierre\": 20, \"MENU_TAG_UNICO\": 21, \"CierreTagUnico\": 22, \"AbreTagConf\": 23, \"CierreTagConf\": 24, \"ATRIBUTO\": 25, \"ListaA\": 26, \"NombreAtributo\": 27, \"IgualAtributo\": 28, \"ValorAtributo\": 29, \"$accept\": 0, \"$end\": 1 },\r\n        terminals_: { 2: \"error\", 6: \"EOF\", 12: \"AbreTagApertura\", 14: \"CierreTagApertura\", 16: \"CadenaValores\", 19: \"AbreTagCierre\", 20: \"CierreTagCierre\", 22: \"CierreTagUnico\", 23: \"AbreTagConf\", 24: \"CierreTagConf\", 27: \"NombreAtributo\", 28: \"IgualAtributo\", 29: \"ValorAtributo\" },\r\n        productions_: [0, [3, 3], [3, 2], [5, 2], [8, 2], [8, 0], [7, 2], [7, 1], [7, 2], [13, 1], [13, 1], [10, 2], [10, 2], [10, 1], [9, 2], [17, 2], [17, 1], [15, 2], [11, 2], [21, 2], [21, 1], [4, 3], [18, 2], [26, 2], [26, 0], [25, 3]],\r\n        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\r\n            /* this == yyval */\r\n            var $0 = $$.length - 1;\r\n            switch (yystate) {\r\n                case 1:\r\n                    this.$ = new XmlResultado($$[$0 - 2], $$[$0 - 1]);\r\n                    return this.$;\r\n                    new ReporteGramatica(\"XML -> TAG_CONFIGURACION LISTA_ETIQUETAS EOF\", \"XML.val = TAG_CONFIGURACION.val+LISTA_ETIQUETAS.val\");\r\n                    break;\r\n                case 2:\r\n                    this.$ = new XmlResultado(null, $$[$0]);\r\n                    return this.$;\r\n                    new ReporteGramatica(\"XML -> N LISTA_ETIQUETAS EOF\", \"XML.val = LISTA_ETIQUETAS.val\");\r\n                    break;\r\n                case 3:\r\n                    $$[$0].push($$[$0 - 1]);\r\n                    this.$ = $$[$0];\r\n                    new ReporteGramatica(\"LISTA_ETIQUETAS -> ETIQUETA ListaEtiqueta \", \"LISTA_ETIQUETAS.val=ListaEtiqueta.val--- ListaEtiqueta = new Array(ETIQUETA)     ////    ListaEtiqueta.push(ETIQUETA.val)\");\r\n                    break;\r\n                case 4:\r\n                    $$[$0].push($$[$0 - 1]);\r\n                    this.$ = $$[$0];\r\n                    new ReporteGramatica(\"ListaEtiqueta -> ETIQUETA ListaEtiqueta \", \"    ListaEtiqueta.push(ETIQUETA.val)\");\r\n                    break;\r\n                case 5:\r\n                    this.$ = [];\r\n                    new ReporteGramatica(\"ListaEtiqueta -> epsilon \", \"  ListaEtiqueta.val = []\");\r\n                    break;\r\n                case 6:\r\n                    this.$ = new EtiquetaDoble($$[$0 - 1].nombreTagApertura, $$[$0].nombreTagCierre, $$[$0 - 1].listaAtributos, $$[$0].cadena, $$[$0].listaEtiqueta, _$[$0 - 1].first_line, _$[$0 - 1].first_column, getId());\r\n                    new ReporteGramatica(\"ETIQUETA -> TAG_APERTURA MenuEtiqueta \", \" ETIQUTA.val= new EtiquetaDoble(TAG_APERTURA.val, MenuEtiqueta.val)\");\r\n                    break;\r\n                case 7:\r\n                    this.$ = $$[$0];\r\n                    new ReporteGramatica(\"ETIQUETA -> TAG_UNICO    \", \" ETIQUTA.val= TAG_UNICO.val\");\r\n                    break;\r\n                case 8:\r\n                    this.$ = new ControlError(yytext, TipoSeleccion.ERROR_SINTACTICO, this._$.first_line, this._$.first_column, \"XmlDEscendiente\");\r\n                    break;\r\n                case 9:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 10:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 11:\r\n                    this.$ = {\r\n                        nombreTagCierre: $$[$0],\r\n                        listaEtiqueta: $$[$0 - 1],\r\n                        cadena: ''\r\n                    };\r\n                    new ReporteGramatica(\"MenuEtiqueta -> LISTA_ETIQUETAS TAG_CIERRE    \", \" MenuEtiqueta.val= LISTA_ETIQUETAS.val +TAG_CIERRE.val\");\r\n                    break;\r\n                case 12:\r\n                    this.$ = {\r\n                        nombreTagCierre: $$[$0],\r\n                        listaEtiqueta: [],\r\n                        cadena: $$[$0 - 1]\r\n                    };\r\n                    new ReporteGramatica(\"MenuEtiqueta ->  CadenaValores TAG_CIERRE  \", \" MenuEtiqueta.val= CadenaValores.lexval +TAG_CIERRE.val\");\r\n                    break;\r\n                case 13:\r\n                    this.$ = {\r\n                        nombreTagCierre: $$[$0],\r\n                        listaEtiqueta: [],\r\n                        cadena: ''\r\n                    };\r\n                    new ReporteGramatica(\"MenuEtiqueta ->   TAG_CIERRE  \", \" MenuEtiqueta.val=TAG_CIERRE.val\");\r\n                    break;\r\n                case 14:\r\n                    this.$ = {\r\n                        nombreTagApertura: formatTagName($$[$0 - 1]),\r\n                        listaAtributos: $$[$0].listaAtributos_\r\n                    };\r\n                    new ReporteGramatica(\"TAG_APERTURA ->   AbreTagApertura MENU_TAG_APERTURA \", \" TAG_APERTURA.val=  AbreTagApertura.lexval+ MENU_TAG_APERTURA.val\");\r\n                    break;\r\n                case 15:\r\n                    this.$ = {\r\n                        listaAtributos_: $$[$0 - 1]\r\n                    };\r\n                    new ReporteGramatica(\"MENU_TAG_APERTURA: ->   LISTA_ATRIBUTOS CierreTagApertura \", \" MENU_TAG_APERTURA.val=  LISTA_ATRIBUTOS.val+ CierreTagApertura.lexval\");\r\n                    break;\r\n                case 16:\r\n                    this.$ = {\r\n                        listaAtributos_: []\r\n                    };\r\n                    new ReporteGramatica(\"MENU_TAG_APERTURA: ->    CierreTagApertura \", \" MENU_TAG_APERTURA.val=   CierreTagApertura.lexval\");\r\n                    break;\r\n                case 17:\r\n                    this.$ = formatTagName(formatTagName($$[$0 - 1]));\r\n                    new ReporteGramatica(\"TAG_CIERRE ->AbreTagApertura CierreTagApertura \", \"TAG_CIERRE.val =AbreTagApertura.lexval  + CierreTagApertura.lexval \");\r\n                    break;\r\n                case 18:\r\n                    this.$ = new EtiquetaSimple(formatTagName($$[$0 - 1]), $$[$0].listaAtributos_unico, _$[$0 - 1].first_line, _$[$0 - 1].first_column, getId());\r\n                    new ReporteGramatica(\"TAG_UNICO: ->    AbreTagApertura MENU_TAG_UNICO\", \" TAG_UNICO.val=   AbreTagApertura.lexval+ MENU_TAG_UNICO.val\");\r\n                    break;\r\n                case 19:\r\n                    this.$ = {\r\n                        listaAtributos_unico: $$[$0 - 1]\r\n                    };\r\n                    new ReporteGramatica(\"MENU_TAG_UNICO: ->    LISTA_ATRIBUTOS CierreTagUnico\", \" MENU_TAG_UNICO.val=   LISTA_ATRIBUTOS.val +CierreTagUnico.lexval\");\r\n                    break;\r\n                case 20:\r\n                    this.$ = {\r\n                        listaAtributos_unico: []\r\n                    };\r\n                    new ReporteGramatica(\"MENU_TAG_UNICO: ->    CierreTagUnico\", \" MENU_TAG_UNICO.val=   CierreTagUnico.lexval\");\r\n                    break;\r\n                case 21:\r\n                    this.$ = new EtiquetaInicio($$[$0 - 1], _$[$0 - 2].first_line, _$[$0 - 2].first_column, getId());\r\n                    new ReporteGramatica(\"TAG_CONFIGURACION: ->    AbreTagConf LISTA_ATRIBUTOS CierreTagConf \", \" TAG_CONFIGURACION.val=     AbreTagConf.lexval LISTA_ATRIBUTOS.val CierreTagConf.lexval \");\r\n                    break;\r\n                case 22:\r\n                    $$[$0].push($$[$0 - 1]);\r\n                    this.$ = $$[$0];\r\n                    new ReporteGramatica(\"LISTA_ATRIBUTOS -> ATRIBUTO ListaA \", \"LISTA_ATRIBUTOS.val=ListaA.val--- ListaA = new Array(ATRIBUTO)     ////    ListaA.push(ATRIBUTO.val)\");\r\n                    break;\r\n                case 23:\r\n                    $$[$0].push($$[$0 - 1]);\r\n                    this.$ = $$[$0];\r\n                    new ReporteGramatica(\"ListaA -> ATRIBUTO ListaA \", \"    ListaA.push(ATRIBUTO.val)\");\r\n                    break;\r\n                case 24:\r\n                    this.$ = [];\r\n                    new ReporteGramatica(\"ListaA -> epsilon \", \"  ListaA.val = []\");\r\n                    break;\r\n                case 25:\r\n                    this.$ = new Atributo($$[$0 - 2], $$[$0], _$[$0 - 2].first_line, _$[$0 - 2].first_column, getId());\r\n                    new ReporteGramatica(\"ATRIBUTO -> NombreAtributo IgualAtributo ValorAtributo  \", \"ATRIBUTO.val=new Atributo (NombreAtributo.lexval,IgualAtributo.lexval,ValorAtributo.lexval)\");\r\n                    break;\r\n            }\r\n        },\r\n        table: [{ 2: $V0, 3: 1, 4: 2, 5: 3, 7: 5, 9: 6, 11: 7, 12: $V1, 23: [1, 4] }, { 1: [3] }, { 2: $V0, 5: 10, 7: 5, 9: 6, 11: 7, 12: $V1 }, { 6: [1, 11] }, { 18: 12, 25: 13, 27: $V2 }, o($V3, $V4, { 9: 6, 11: 7, 8: 15, 7: 16, 2: $V0, 12: $V1 }), { 2: $V0, 5: 18, 7: 5, 9: 6, 10: 17, 11: 7, 12: $V1, 15: 20, 16: [1, 19], 19: $V5 }, o($V6, [2, 7]), { 12: [1, 22] }, { 14: [1, 26], 17: 23, 18: 25, 21: 24, 22: [1, 27], 25: 13, 27: $V2 }, { 6: [1, 28] }, { 1: [2, 2] }, { 24: [1, 29] }, o($V7, $V8, { 26: 30, 25: 31, 27: $V2 }), { 28: [1, 32] }, o($V3, [2, 3]), o($V3, $V4, { 9: 6, 11: 7, 7: 16, 8: 33, 2: $V0, 12: $V1 }), o($V6, [2, 6]), { 15: 34, 19: $V5 }, { 15: 35, 19: $V5 }, o($V6, [2, 13]), { 20: [1, 36] }, o($V6, [2, 8]), o($V9, [2, 14]), o($V6, [2, 18]), { 14: [1, 37], 22: [1, 38] }, o($V9, [2, 16]), o($V6, [2, 20]), { 1: [2, 1] }, o($Va, [2, 21]), o($V7, [2, 22]), o($V7, $V8, { 25: 31, 26: 39, 27: $V2 }), { 29: [1, 40] }, o($V3, [2, 4]), o($V6, [2, 11]), o($V6, $Va), o($V6, [2, 17]), o($V9, [2, 15]), o($V6, [2, 19]), o($V7, [2, 23]), o([14, 22, 24, 27], [2, 25])],\r\n        defaultActions: { 11: [2, 2], 28: [2, 1] },\r\n        parseError: function parseError(str, hash) {\r\n            if (hash.recoverable) {\r\n                this.trace(str);\r\n            }\r\n            else {\r\n                var error = new Error(str);\r\n                error.hash = hash;\r\n                throw error;\r\n            }\r\n        },\r\n        parse: function parse(input) {\r\n            var self = this, stack = [0], tstack = [], // token stack\r\n            vstack = [null], // semantic value stack\r\n            lstack = [], // location stack\r\n            table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\r\n            var args = lstack.slice.call(arguments, 1);\r\n            //this.reductionCount = this.shiftCount = 0;\r\n            var lexer = Object.create(this.lexer);\r\n            var sharedState = { yy: {} };\r\n            // copy state\r\n            for (var k in this.yy) {\r\n                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\r\n                    sharedState.yy[k] = this.yy[k];\r\n                }\r\n            }\r\n            lexer.setInput(input, sharedState.yy);\r\n            sharedState.yy.lexer = lexer;\r\n            sharedState.yy.parser = this;\r\n            if (typeof lexer.yylloc == 'undefined') {\r\n                lexer.yylloc = {};\r\n            }\r\n            var yyloc = lexer.yylloc;\r\n            lstack.push(yyloc);\r\n            var ranges = lexer.options && lexer.options.ranges;\r\n            if (typeof sharedState.yy.parseError === 'function') {\r\n                this.parseError = sharedState.yy.parseError;\r\n            }\r\n            else {\r\n                this.parseError = Object.getPrototypeOf(this).parseError;\r\n            }\r\n            function popStack(n) {\r\n                stack.length = stack.length - 2 * n;\r\n                vstack.length = vstack.length - n;\r\n                lstack.length = lstack.length - n;\r\n            }\r\n            _token_stack: var lex = function () {\r\n                var token;\r\n                token = lexer.lex() || EOF;\r\n                // if token isn't its numeric value, convert\r\n                if (typeof token !== 'number') {\r\n                    token = self.symbols_[token] || token;\r\n                }\r\n                return token;\r\n            };\r\n            var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\r\n            while (true) {\r\n                // retreive state number from top of stack\r\n                state = stack[stack.length - 1];\r\n                // use default actions if available\r\n                if (this.defaultActions[state]) {\r\n                    action = this.defaultActions[state];\r\n                }\r\n                else {\r\n                    if (symbol === null || typeof symbol == 'undefined') {\r\n                        symbol = lex();\r\n                    }\r\n                    // read action for current state and first input\r\n                    action = table[state] && table[state][symbol];\r\n                }\r\n                _handle_error: \r\n                // handle parse error\r\n                if (typeof action === 'undefined' || !action.length || !action[0]) {\r\n                    var error_rule_depth;\r\n                    var errStr = '';\r\n                    // Return the rule stack depth where the nearest error rule can be found.\r\n                    // Return FALSE when no error recovery rule was found.\r\n                    function locateNearestErrorRecoveryRule(state) {\r\n                        var stack_probe = stack.length - 1;\r\n                        var depth = 0;\r\n                        // try to recover from error\r\n                        for (;;) {\r\n                            // check for error recovery rule in this state\r\n                            if ((TERROR.toString()) in table[state]) {\r\n                                return depth;\r\n                            }\r\n                            if (state === 0 || stack_probe < 2) {\r\n                                return false; // No suitable error recovery rule available.\r\n                            }\r\n                            stack_probe -= 2; // popStack(1): [symbol, action]\r\n                            state = stack[stack_probe];\r\n                            ++depth;\r\n                        }\r\n                    }\r\n                    if (!recovering) {\r\n                        // first see if there's any chance at hitting an error recovery rule:\r\n                        error_rule_depth = locateNearestErrorRecoveryRule(state);\r\n                        // Report error\r\n                        expected = [];\r\n                        for (p in table[state]) {\r\n                            if (this.terminals_[p] && p > TERROR) {\r\n                                expected.push(\"'\" + this.terminals_[p] + \"'\");\r\n                            }\r\n                        }\r\n                        if (lexer.showPosition) {\r\n                            errStr = 'Parse error on line ' + (yylineno + 1) + \":\\n\" + lexer.showPosition() + \"\\nExpecting \" + expected.join(', ') + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\r\n                        }\r\n                        else {\r\n                            errStr = 'Parse error on line ' + (yylineno + 1) + \": Unexpected \" +\r\n                                (symbol == EOF ? \"end of input\" :\r\n                                    (\"'\" + (this.terminals_[symbol] || symbol) + \"'\"));\r\n                        }\r\n                        this.parseError(errStr, {\r\n                            text: lexer.match,\r\n                            token: this.terminals_[symbol] || symbol,\r\n                            line: lexer.yylineno,\r\n                            loc: yyloc,\r\n                            expected: expected,\r\n                            recoverable: (error_rule_depth !== false)\r\n                        });\r\n                    }\r\n                    else if (preErrorSymbol !== EOF) {\r\n                        error_rule_depth = locateNearestErrorRecoveryRule(state);\r\n                    }\r\n                    // just recovered from another error\r\n                    if (recovering == 3) {\r\n                        if (symbol === EOF || preErrorSymbol === EOF) {\r\n                            throw new Error(errStr || 'Parsing halted while starting to recover from another error.');\r\n                        }\r\n                        // discard current lookahead and grab another\r\n                        yyleng = lexer.yyleng;\r\n                        yytext = lexer.yytext;\r\n                        yylineno = lexer.yylineno;\r\n                        yyloc = lexer.yylloc;\r\n                        symbol = lex();\r\n                    }\r\n                    // try to recover from error\r\n                    if (error_rule_depth === false) {\r\n                        throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');\r\n                    }\r\n                    popStack(error_rule_depth);\r\n                    preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token\r\n                    symbol = TERROR; // insert generic error symbol as new lookahead\r\n                    state = stack[stack.length - 1];\r\n                    action = table[state] && table[state][TERROR];\r\n                    recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\r\n                }\r\n                // this shouldn't happen, unless resolve defaults are off\r\n                if (action[0] instanceof Array && action.length > 1) {\r\n                    throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\r\n                }\r\n                switch (action[0]) {\r\n                    case 1: // shift\r\n                        //this.shiftCount++;\r\n                        stack.push(symbol);\r\n                        vstack.push(lexer.yytext);\r\n                        lstack.push(lexer.yylloc);\r\n                        stack.push(action[1]); // push state\r\n                        symbol = null;\r\n                        if (!preErrorSymbol) { // normal execution/no error\r\n                            yyleng = lexer.yyleng;\r\n                            yytext = lexer.yytext;\r\n                            yylineno = lexer.yylineno;\r\n                            yyloc = lexer.yylloc;\r\n                            if (recovering > 0) {\r\n                                recovering--;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // error just occurred, resume old lookahead f/ before error\r\n                            symbol = preErrorSymbol;\r\n                            preErrorSymbol = null;\r\n                        }\r\n                        break;\r\n                    case 2:\r\n                        // reduce\r\n                        //this.reductionCount++;\r\n                        len = this.productions_[action[1]][1];\r\n                        // perform semantic action\r\n                        yyval.$ = vstack[vstack.length - len]; // default to $$ = $1\r\n                        // default location, uses first token for firsts, last for lasts\r\n                        yyval._$ = {\r\n                            first_line: lstack[lstack.length - (len || 1)].first_line,\r\n                            last_line: lstack[lstack.length - 1].last_line,\r\n                            first_column: lstack[lstack.length - (len || 1)].first_column,\r\n                            last_column: lstack[lstack.length - 1].last_column\r\n                        };\r\n                        if (ranges) {\r\n                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\r\n                        }\r\n                        r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));\r\n                        if (typeof r !== 'undefined') {\r\n                            return r;\r\n                        }\r\n                        // pop off stack\r\n                        if (len) {\r\n                            stack = stack.slice(0, -1 * len * 2);\r\n                            vstack = vstack.slice(0, -1 * len);\r\n                            lstack = lstack.slice(0, -1 * len);\r\n                        }\r\n                        stack.push(this.productions_[action[1]][0]); // push nonterminal (reduce)\r\n                        vstack.push(yyval.$);\r\n                        lstack.push(yyval._$);\r\n                        // goto new state = table[STATE][NONTERMINAL]\r\n                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\r\n                        stack.push(newState);\r\n                        break;\r\n                    case 3:\r\n                        // accept\r\n                        return true;\r\n                }\r\n            }\r\n            return true;\r\n        } };\r\n    const { EtiquetaDoble } = require('../Xml/EtiquetaDoble');\r\n    const { EtiquetaSimple } = require('../Xml/EtiquetaSimple');\r\n    const { EtiquetaInicio } = require('../Xml/EtiquetaInicio');\r\n    const { Atributo } = require('../Xml/Atributo');\r\n    const { XmlResultado } = require('../Xml/XmlResultado');\r\n    const { ControlError } = require('../Xpath/ControlError');\r\n    const { ReporteGramatica } = require('../Reportes/ReporteGramatica');\r\n    let idSent = 1;\r\n    function getId() {\r\n        idSent += 100;\r\n        return idSent;\r\n    }\r\n    function formatTagName(AbreTagApertura) {\r\n        return AbreTagApertura.substring(1, AbreTagApertura.length);\r\n    }\r\n    listaError = [];\r\n    /* generated by jison-lex 0.3.4 */\r\n    var lexer = (function () {\r\n        var lexer = ({\r\n            EOF: 1,\r\n            parseError: function parseError(str, hash) {\r\n                if (this.yy.parser) {\r\n                    this.yy.parser.parseError(str, hash);\r\n                }\r\n                else {\r\n                    throw new Error(str);\r\n                }\r\n            },\r\n            // resets the lexer, sets new input\r\n            setInput: function (input, yy) {\r\n                this.yy = yy || this.yy || {};\r\n                this._input = input;\r\n                this._more = this._backtrack = this.done = false;\r\n                this.yylineno = this.yyleng = 0;\r\n                this.yytext = this.matched = this.match = '';\r\n                this.conditionStack = ['INITIAL'];\r\n                this.yylloc = {\r\n                    first_line: 1,\r\n                    first_column: 0,\r\n                    last_line: 1,\r\n                    last_column: 0\r\n                };\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [0, 0];\r\n                }\r\n                this.offset = 0;\r\n                return this;\r\n            },\r\n            // consumes and returns one char from the input\r\n            input: function () {\r\n                var ch = this._input[0];\r\n                this.yytext += ch;\r\n                this.yyleng++;\r\n                this.offset++;\r\n                this.match += ch;\r\n                this.matched += ch;\r\n                var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\r\n                if (lines) {\r\n                    this.yylineno++;\r\n                    this.yylloc.last_line++;\r\n                }\r\n                else {\r\n                    this.yylloc.last_column++;\r\n                }\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range[1]++;\r\n                }\r\n                this._input = this._input.slice(1);\r\n                return ch;\r\n            },\r\n            // unshifts one char (or a string) into the input\r\n            unput: function (ch) {\r\n                var len = ch.length;\r\n                var lines = ch.split(/(?:\\r\\n?|\\n)/g);\r\n                this._input = ch + this._input;\r\n                this.yytext = this.yytext.substr(0, this.yytext.length - len);\r\n                //this.yyleng -= len;\r\n                this.offset -= len;\r\n                var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\r\n                this.match = this.match.substr(0, this.match.length - 1);\r\n                this.matched = this.matched.substr(0, this.matched.length - 1);\r\n                if (lines.length - 1) {\r\n                    this.yylineno -= lines.length - 1;\r\n                }\r\n                var r = this.yylloc.range;\r\n                this.yylloc = {\r\n                    first_line: this.yylloc.first_line,\r\n                    last_line: this.yylineno + 1,\r\n                    first_column: this.yylloc.first_column,\r\n                    last_column: lines ?\r\n                        (lines.length === oldLines.length ? this.yylloc.first_column : 0)\r\n                            + oldLines[oldLines.length - lines.length].length - lines[0].length :\r\n                        this.yylloc.first_column - len\r\n                };\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];\r\n                }\r\n                this.yyleng = this.yytext.length;\r\n                return this;\r\n            },\r\n            // When called from action, caches matched text and appends it on next action\r\n            more: function () {\r\n                this._more = true;\r\n                return this;\r\n            },\r\n            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\r\n            reject: function () {\r\n                if (this.options.backtrack_lexer) {\r\n                    this._backtrack = true;\r\n                }\r\n                else {\r\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\r\n                        text: \"\",\r\n                        token: null,\r\n                        line: this.yylineno\r\n                    });\r\n                }\r\n                return this;\r\n            },\r\n            // retain first n characters of the match\r\n            less: function (n) {\r\n                this.unput(this.match.slice(n));\r\n            },\r\n            // displays already matched input, i.e. for error messages\r\n            pastInput: function () {\r\n                var past = this.matched.substr(0, this.matched.length - this.match.length);\r\n                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\\n/g, \"\");\r\n            },\r\n            // displays upcoming input, i.e. for error messages\r\n            upcomingInput: function () {\r\n                var next = this.match;\r\n                if (next.length < 20) {\r\n                    next += this._input.substr(0, 20 - next.length);\r\n                }\r\n                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\r\n            },\r\n            // displays the character position where the lexing error occurred, i.e. for error messages\r\n            showPosition: function () {\r\n                var pre = this.pastInput();\r\n                var c = new Array(pre.length + 1).join(\"-\");\r\n                return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\r\n            },\r\n            // test the lexed token: return FALSE when not a match, otherwise return token\r\n            test_match: function (match, indexed_rule) {\r\n                var token, lines, backup;\r\n                if (this.options.backtrack_lexer) {\r\n                    // save context\r\n                    backup = {\r\n                        yylineno: this.yylineno,\r\n                        yylloc: {\r\n                            first_line: this.yylloc.first_line,\r\n                            last_line: this.last_line,\r\n                            first_column: this.yylloc.first_column,\r\n                            last_column: this.yylloc.last_column\r\n                        },\r\n                        yytext: this.yytext,\r\n                        match: this.match,\r\n                        matches: this.matches,\r\n                        matched: this.matched,\r\n                        yyleng: this.yyleng,\r\n                        offset: this.offset,\r\n                        _more: this._more,\r\n                        _input: this._input,\r\n                        yy: this.yy,\r\n                        conditionStack: this.conditionStack.slice(0),\r\n                        done: this.done\r\n                    };\r\n                    if (this.options.ranges) {\r\n                        backup.yylloc.range = this.yylloc.range.slice(0);\r\n                    }\r\n                }\r\n                lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\r\n                if (lines) {\r\n                    this.yylineno += lines.length;\r\n                }\r\n                this.yylloc = {\r\n                    first_line: this.yylloc.last_line,\r\n                    last_line: this.yylineno + 1,\r\n                    first_column: this.yylloc.last_column,\r\n                    last_column: lines ?\r\n                        lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\r\n                        this.yylloc.last_column + match[0].length\r\n                };\r\n                this.yytext += match[0];\r\n                this.match += match[0];\r\n                this.matches = match;\r\n                this.yyleng = this.yytext.length;\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [this.offset, this.offset += this.yyleng];\r\n                }\r\n                this._more = false;\r\n                this._backtrack = false;\r\n                this._input = this._input.slice(match[0].length);\r\n                this.matched += match[0];\r\n                token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\r\n                if (this.done && this._input) {\r\n                    this.done = false;\r\n                }\r\n                if (token) {\r\n                    return token;\r\n                }\r\n                else if (this._backtrack) {\r\n                    // recover context\r\n                    for (var k in backup) {\r\n                        this[k] = backup[k];\r\n                    }\r\n                    return false; // rule action called reject() implying the next rule should be tested instead.\r\n                }\r\n                return false;\r\n            },\r\n            // return next match in input\r\n            next: function () {\r\n                if (this.done) {\r\n                    return this.EOF;\r\n                }\r\n                if (!this._input) {\r\n                    this.done = true;\r\n                }\r\n                var token, match, tempMatch, index;\r\n                if (!this._more) {\r\n                    this.yytext = '';\r\n                    this.match = '';\r\n                }\r\n                var rules = this._currentRules();\r\n                for (var i = 0; i < rules.length; i++) {\r\n                    tempMatch = this._input.match(this.rules[rules[i]]);\r\n                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\r\n                        match = tempMatch;\r\n                        index = i;\r\n                        if (this.options.backtrack_lexer) {\r\n                            token = this.test_match(tempMatch, rules[i]);\r\n                            if (token !== false) {\r\n                                return token;\r\n                            }\r\n                            else if (this._backtrack) {\r\n                                match = false;\r\n                                continue; // rule action called reject() implying a rule MISmatch.\r\n                            }\r\n                            else {\r\n                                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n                                return false;\r\n                            }\r\n                        }\r\n                        else if (!this.options.flex) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (match) {\r\n                    token = this.test_match(match, rules[index]);\r\n                    if (token !== false) {\r\n                        return token;\r\n                    }\r\n                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n                    return false;\r\n                }\r\n                if (this._input === \"\") {\r\n                    return this.EOF;\r\n                }\r\n                else {\r\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\r\n                        text: \"\",\r\n                        token: null,\r\n                        line: this.yylineno\r\n                    });\r\n                }\r\n            },\r\n            // return next match that has a token\r\n            lex: function lex() {\r\n                var r = this.next();\r\n                if (r) {\r\n                    return r;\r\n                }\r\n                else {\r\n                    return this.lex();\r\n                }\r\n            },\r\n            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\r\n            begin: function begin(condition) {\r\n                this.conditionStack.push(condition);\r\n            },\r\n            // pop the previously active lexer condition state off the condition stack\r\n            popState: function popState() {\r\n                var n = this.conditionStack.length - 1;\r\n                if (n > 0) {\r\n                    return this.conditionStack.pop();\r\n                }\r\n                else {\r\n                    return this.conditionStack[0];\r\n                }\r\n            },\r\n            // produce the lexer rule set which is active for the currently active lexer condition state\r\n            _currentRules: function _currentRules() {\r\n                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\r\n                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\r\n                }\r\n                else {\r\n                    return this.conditions[\"INITIAL\"].rules;\r\n                }\r\n            },\r\n            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\r\n            topState: function topState(n) {\r\n                n = this.conditionStack.length - 1 - Math.abs(n || 0);\r\n                if (n >= 0) {\r\n                    return this.conditionStack[n];\r\n                }\r\n                else {\r\n                    return \"INITIAL\";\r\n                }\r\n            },\r\n            // alias for begin(condition)\r\n            pushState: function pushState(condition) {\r\n                this.begin(condition);\r\n            },\r\n            // return the number of states currently on the stack\r\n            stateStackSize: function stateStackSize() {\r\n                return this.conditionStack.length;\r\n            },\r\n            options: { \"case-insensitive\": true },\r\n            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\r\n                var YYSTATE = YY_START;\r\n                switch ($avoiding_name_collisions) {\r\n                    case 0:\r\n                        this.begin(\"Comentario\");\r\n                        break;\r\n                    case 1:\r\n                        break;\r\n                    case 2:\r\n                        break;\r\n                    case 3:\r\n                        break;\r\n                    case 4:\r\n                        this.popState();\r\n                        break;\r\n                    case 5:\r\n                        break;\r\n                    case 6:\r\n                        this.begin(\"TagApertura\");\r\n                        return 23;\r\n                        break;\r\n                    case 7:\r\n                        break;\r\n                    case 8:\r\n                        return 27;\r\n                        break;\r\n                    case 9:\r\n                        return 28;\r\n                        break;\r\n                    case 10:\r\n                        return 29;\r\n                        break;\r\n                    case 11:\r\n                        this.popState();\r\n                        return 24;\r\n                        break;\r\n                    case 12:\r\n                        this.begin(\"TagApertura\");\r\n                        return 12;\r\n                        break;\r\n                    case 13:\r\n                        break;\r\n                    case 14:\r\n                        return 27;\r\n                        break;\r\n                    case 15:\r\n                        return 28;\r\n                        break;\r\n                    case 16:\r\n                        return 29;\r\n                        break;\r\n                    case 17:\r\n                        this.popState();\r\n                        return 14;\r\n                        break;\r\n                    case 18:\r\n                        this.popState();\r\n                        return 22;\r\n                        break;\r\n                    case 19:\r\n                        this.begin(\"TagCierre\");\r\n                        return 19;\r\n                        break;\r\n                    case 20:\r\n                        this.popState();\r\n                        return 20;\r\n                        break;\r\n                    case 21:\r\n                        break;\r\n                    case 22:\r\n                        return 16;\r\n                        break;\r\n                    case 23:\r\n                        return 6;\r\n                        break;\r\n                    case 24:\r\n                        new ControlError(yy_.yytext, TipoSeleccion.ERROR_LEXICO, yy_.yylloc.first_line, yy_.yylloc.first_column, \"XmlDescendente\");\r\n                        break;\r\n                }\r\n            },\r\n            rules: [/^(?:<!--)/i, /^(?:[\\r\\t\\&\\$\\@\\#\\?\\\\\\{\\}\\(\\)\\,\\.]+)/i, /^(?:\\n)/i, /^(?:\\n)/i, /^(?:-->)/i, /^(?:[^\"-->\"]+)/i, /^(?:<\\?xml\\b)/i, /^(?:[\\s\\r\\t\\n]+)/i, /^(?:[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:=)/i, /^(?:\"[^\\\"\\n]*\")/i, /^(?:\\?>)/i, /^(?:<[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:[\\s\\r\\t\\n]+)/i, /^(?:[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:=)/i, /^(?:\"[^\\\"\\n]*\")/i, /^(?:>)/i, /^(?:\\/>)/i, /^(?:<\\/[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:>)/i, /^(?:[\\s\\r\\t\\n]+)/i, /^(?:[^<]+)/i, /^(?:$)/i, /^(?:.)/i],\r\n            conditions: { \"TagCierre\": { \"rules\": [20], \"inclusive\": false }, \"TagApertura\": { \"rules\": [7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 18], \"inclusive\": false }, \"Comentario\": { \"rules\": [1, 2, 3, 4, 5], \"inclusive\": false }, \"INITIAL\": { \"rules\": [0, 6, 12, 19, 21, 22, 23, 24], \"inclusive\": true } }\r\n        });\r\n        return lexer;\r\n    })();\r\n    parser.lexer = lexer;\r\n    function Parser() {\r\n        this.yy = {};\r\n    }\r\n    Parser.prototype = parser;\r\n    parser.Parser = Parser;\r\n    return new Parser;\r\n})();\r\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\r\n    exports.parser = xmlD;\r\n    exports.Parser = xmlD.Parser;\r\n    exports.parse = function () { return xmlD.parse.apply(xmlD, arguments); };\r\n    exports.main = function commonjsMain(args) {\r\n        if (!args[1]) {\r\n            console.log('Usage: ' + args[0] + ' FILE');\r\n            process.exit(1);\r\n        }\r\n        var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\r\n        return exports.parser.parse(source);\r\n    };\r\n    if (typeof module !== 'undefined' && require.main === module) {\r\n        exports.main(process.argv.slice(1));\r\n    }\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass Primitivo {\r\n    constructor(valor, tipo) {\r\n        this.valor = valor;\r\n        this.tipo = tipo;\r\n    }\r\n    ejecutar() {\r\n        return this;\r\n    }\r\n}\r\nexports.Primitivo = Primitivo;\r\n","/* parser generated by jison 0.4.18 */\r\n/*\r\n  Returns a Parser object of the following structure:\r\n\r\n  Parser: {\r\n    yy: {}\r\n  }\r\n\r\n  Parser.prototype: {\r\n    yy: {},\r\n    trace: function(),\r\n    symbols_: {associative list: name ==> number},\r\n    terminals_: {associative list: number ==> name},\r\n    productions_: [...],\r\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\r\n    table: [...],\r\n    defaultActions: {...},\r\n    parseError: function(str, hash),\r\n    parse: function(input),\r\n\r\n    lexer: {\r\n        EOF: 1,\r\n        parseError: function(str, hash),\r\n        setInput: function(input),\r\n        input: function(),\r\n        unput: function(str),\r\n        more: function(),\r\n        less: function(n),\r\n        pastInput: function(),\r\n        upcomingInput: function(),\r\n        showPosition: function(),\r\n        test_match: function(regex_match_array, rule_index),\r\n        next: function(),\r\n        lex: function(),\r\n        begin: function(condition),\r\n        popState: function(),\r\n        _currentRules: function(),\r\n        topState: function(),\r\n        pushState: function(condition),\r\n\r\n        options: {\r\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\r\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\r\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\r\n        },\r\n\r\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\r\n        rules: [...],\r\n        conditions: {associative list: name ==> set},\r\n    }\r\n  }\r\n\r\n\r\n  token location info (@$, _$, etc.): {\r\n    first_line: n,\r\n    last_line: n,\r\n    first_column: n,\r\n    last_column: n,\r\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\r\n  }\r\n\r\n\r\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\r\n    text:        (matched text)\r\n    token:       (the produced terminal token, if any)\r\n    line:        (yylineno)\r\n  }\r\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\r\n    loc:         (yylloc)\r\n    expected:    (string describing the set of expected tokens)\r\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\r\n  }\r\n*/\r\nvar xmlA = (function () {\r\n    var o = function (k, v, o, l) { for (o = o || {}, l = k.length; l--; o[k[l]] = v)\r\n        ; return o; }, $V0 = [1, 8], $V1 = [1, 9], $V2 = [1, 15], $V3 = [2, 6, 12, 16], $V4 = [1, 19], $V5 = [14, 18, 20, 22], $V6 = [2, 10, 12, 16], $V7 = [2, 12];\r\n    var parser = { trace: function trace() { },\r\n        yy: {},\r\n        symbols_: { \"error\": 2, \"XML\": 3, \"TAG_CONFIGURACION\": 4, \"LISTA_ETIQUETAS\": 5, \"EOF\": 6, \"ETIQUETA\": 7, \"TAG_APERTURA\": 8, \"TAG_CIERRE\": 9, \"CadenaValores\": 10, \"TAG_UNICO\": 11, \"AbreTagApertura\": 12, \"DELIMITADOR\": 13, \"CierreTagApertura\": 14, \"LISTA_ATRIBUTOS\": 15, \"AbreTagCierre\": 16, \"CierreTagCierre\": 17, \"CierreTagUnico\": 18, \"AbreTagConf\": 19, \"CierreTagConf\": 20, \"ATRIBUTO\": 21, \"NombreAtributo\": 22, \"IgualAtributo\": 23, \"ValorAtributo\": 24, \"$accept\": 0, \"$end\": 1 },\r\n        terminals_: { 2: \"error\", 6: \"EOF\", 10: \"CadenaValores\", 12: \"AbreTagApertura\", 14: \"CierreTagApertura\", 16: \"AbreTagCierre\", 17: \"CierreTagCierre\", 18: \"CierreTagUnico\", 19: \"AbreTagConf\", 20: \"CierreTagConf\", 22: \"NombreAtributo\", 23: \"IgualAtributo\", 24: \"ValorAtributo\" },\r\n        productions_: [0, [3, 3], [3, 2], [5, 2], [5, 1], [7, 3], [7, 3], [7, 2], [7, 1], [7, 2], [13, 1], [13, 1], [8, 3], [8, 2], [9, 2], [11, 3], [11, 2], [4, 3], [15, 2], [15, 1], [21, 3]],\r\n        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\r\n            /* this == yyval */\r\n            var $0 = $$.length - 1;\r\n            switch (yystate) {\r\n                case 1:\r\n                    this.$ = new XmlResultado($$[$0 - 2], $$[$0 - 1]);\r\n                    return this.$;\r\n                    new ReporteGramatica(\"XML -> TAG_CONFIGURACION LISTA_ETIQUETAS EOF\", \"XML.val = TAG_CONFIGURACION.val+LISTA_ETIQUETAS.val\");\r\n                    break;\r\n                case 2:\r\n                    this.$ = new XmlResultado(null, $$[$0]);\r\n                    return this.$;\r\n                    new ReporteGramatica(\"XML -> N LISTA_ETIQUETAS EOF\", \"XML.val = LISTA_ETIQUETAS.val\");\r\n                    break;\r\n                case 3:\r\n                    $$[$0 - 1].push($$[$0]);\r\n                    this.$ = $$[$0 - 1];\r\n                    new ReporteGramatica(\"LISTA_ETIQUETAS -> LISTA_ETIQUETAS  ETIQUETA \", \" LISTA_ETIQUETAS = new Array (Etiquetas)              ----    LISTA_ETIQUETAS.push(ETIQUETA.val)\");\r\n                    break;\r\n                case 4:\r\n                    this.$ = [$$[$0]];\r\n                    new ReporteGramatica(\"LISTA_ETIQUETAS ->  ETIQUETA \", \"LISTA_ETIQUETAS.val =[ETIQUETA.val[\");\r\n                    break;\r\n                case 5:\r\n                    this.$ = new EtiquetaDoble($$[$0 - 2].nombreTagApertura, $$[$0], $$[$0 - 2].listaAtributos, '', $$[$0 - 1], _$[$0 - 2].first_line, _$[$0 - 2].first_column, getId());\r\n                    new ReporteGramatica(\"ETIQUETA -> TAG_APERTURA LISTA_ETIQUETAS TAG_CIERRE \", \"ETIQUETA.val = new ETITQUETA_DOBLE (TAG_APERTURA.val,LISTA_ETIQUETAS.val,TAG_CIERRE.val)\");\r\n                    break;\r\n                case 6:\r\n                    this.$ = new EtiquetaDoble($$[$0 - 2].nombreTagApertura, $$[$0], $$[$0 - 2].listaAtributos, $$[$0 - 1], [], _$[$0 - 2].first_line, _$[$0 - 2].first_column, getId());\r\n                    new ReporteGramatica(\"ETIQUETA -> TAG_APERTURA CadenaValores TAG_CIERRE \", \"ETIQUETA.val = new ETITQUETA_DOBLE (TAG_APERTURA.val,CadenaValores.lexval,TAG_CIERRE.val)\");\r\n                    break;\r\n                case 7:\r\n                    this.$ = new EtiquetaDoble($$[$0 - 1].nombreTagApertura, $$[$0], $$[$0 - 1].listaAtributos, '', [], _$[$0 - 1].first_line, _$[$0 - 1].first_column, getId());\r\n                    new ReporteGramatica(\"ETIQUETA -> TAG_APERTURA  TAG_CIERRE \", \"ETIQUETA.val = new ETITQUETA_DOBLE (TAG_APERTURA.val,[],TAG_CIERRE.val)\");\r\n                    break;\r\n                case 8:\r\n                    this.$ = $$[$0];\r\n                    new ReporteGramatica(\"ETIQUETA -> TAG_UNICO \", \"ETIQUETA.val =TAG_UNICO.val\");\r\n                    break;\r\n                case 9:\r\n                    this.$ = listaError.push(new ControlError(yytext, TipoSeleccion.ERROR_SINTACTICO, this._$.first_line, this._$.first_column, \"XPathAscendente\"));\r\n                    break;\r\n                case 10:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 11:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 12:\r\n                    new ReporteGramatica(\"TAG_APERTURA -> AbreTagApertura LISTA_ATRIBUTOS CierreTagApertura \", \"TAG_APERTURA.val =AbreTagApertura.lexval + LISTA_ATRIBUTOS.val + CierreTagApertura.lexval   \");\r\n                    this.$ = {\r\n                        nombreTagApertura: formatTagName($$[$0 - 2]),\r\n                        listaAtributos: $$[$0 - 1]\r\n                    };\r\n                    break;\r\n                case 13:\r\n                    new ReporteGramatica(\"TAG_APERTURA ->AbreTagApertura CierreTagApertura \", \"TAG_APERTURA.val =AbreTagApertura.lexval  + CierreTagApertura.lexval \");\r\n                    this.$ = {\r\n                        nombreTagApertura: formatTagName($$[$0 - 1]),\r\n                        listaAtributos: []\r\n                    };\r\n                    break;\r\n                case 14:\r\n                    this.$ = formatTagName(formatTagName($$[$0 - 1]));\r\n                    new ReporteGramatica(\"TAG_CIERRE ->AbreTagApertura CierreTagApertura \", \"TAG_CIERRE.val =AbreTagApertura.lexval  + CierreTagApertura.lexval \");\r\n                    break;\r\n                case 15:\r\n                    this.$ = new EtiquetaSimple(formatTagName($$[$0 - 2]), $$[$0 - 1], _$[$0 - 2].first_line, _$[$0 - 2].first_column, getId());\r\n                    new ReporteGramatica(\"TAG_UNICO -> AbreTagApertura LISTA_ATRIBUTOS CierreTagUnico \", \"TAG_UNICO.val =new EtiquetaSimple(AbreTagApertura.lexval,LISTA_ATRIBUTOS.val  , CierreTagApertura.lexval) \");\r\n                    break;\r\n                case 16:\r\n                    this.$ = new EtiquetaSimple(formatTagName($$[$0 - 1]), [], _$[$0 - 1].first_line, _$[$0 - 1].first_column, getId());\r\n                    new ReporteGramatica(\"TAG_UNICO ->AbreTagApertura CierreTagApertura \", \"TAG_UNICO.val =new EtiquetaSimple(AbreTagApertura.lexval,[ ]  , CierreTagApertura.lexval) \");\r\n                    break;\r\n                case 17:\r\n                    this.$ = new EtiquetaInicio($$[$0 - 1], _$[$0 - 2].first_line, _$[$0 - 2].first_column, getId());\r\n                    new ReporteGramatica(\"TAG_CONFIGURACION ->AbreTagConf LISTA_ATRIBUTOS CierreTagConf\", \"TAG_CONFIGURACION.val =new EtiquetaInicio(AbreTagConf.lexval,LISTA_ATRIBUTOS.val  , CierreTagConf.lexval) \");\r\n                    break;\r\n                case 18:\r\n                    $$[$0 - 1].push($$[$0]);\r\n                    this.$ = $$[$0 - 1];\r\n                    new ReporteGramatica(\"LISTA_ATRIBUTOS -> LISTA_ATRIBUTOS  ATRIBUTO \", \" LISTA_ATRIBUTO= new Array () ----- LISTA_ATRIBUTO.push(ATRIBUTO.val)\");\r\n                    break;\r\n                case 19:\r\n                    this.$ = [$$[$0]];\r\n                    new ReporteGramatica(\"LISTA_ATRIBUTO -> ATRIBUTO \", \"LISTA_ATRIBUTO.=[ATRIBUTO.val]\");\r\n                    break;\r\n                case 20:\r\n                    new ReporteGramatica(\"ATRIBUTO -> NombreAtributo IgualAtributo ValorAtributo  \", \"ATRIBUTO.val=new Atributo (NombreAtributo.lexval,IgualAtributo.lexval,ValorAtributo.lexval)\");\r\n                    this.$ = new Atributo($$[$0 - 2], $$[$0], _$[$0 - 2].first_line, _$[$0 - 2].first_column, getId());\r\n                    break;\r\n            }\r\n        },\r\n        table: [{ 2: $V0, 3: 1, 4: 2, 5: 3, 7: 5, 8: 6, 11: 7, 12: $V1, 19: [1, 4] }, { 1: [3] }, { 2: $V0, 5: 10, 7: 5, 8: 6, 11: 7, 12: $V1 }, { 2: $V0, 6: [1, 11], 7: 12, 8: 6, 11: 7, 12: $V1 }, { 15: 13, 21: 14, 22: $V2 }, o($V3, [2, 4]), { 2: $V0, 5: 16, 7: 5, 8: 6, 9: 18, 10: [1, 17], 11: 7, 12: $V1, 16: $V4 }, o($V3, [2, 8]), { 12: [1, 20] }, { 14: [1, 22], 15: 21, 18: [1, 23], 21: 14, 22: $V2 }, { 2: $V0, 6: [1, 24], 7: 12, 8: 6, 11: 7, 12: $V1 }, { 1: [2, 2] }, o($V3, [2, 3]), { 20: [1, 25], 21: 26, 22: $V2 }, o($V5, [2, 19]), { 23: [1, 27] }, { 2: $V0, 7: 12, 8: 6, 9: 28, 11: 7, 12: $V1, 16: $V4 }, { 9: 29, 16: $V4 }, o($V3, [2, 7]), { 17: [1, 30] }, o($V3, [2, 9]), { 14: [1, 31], 18: [1, 32], 21: 26, 22: $V2 }, o($V6, [2, 13]), o($V3, [2, 16]), { 1: [2, 1] }, o($V7, [2, 17]), o($V5, [2, 18]), { 24: [1, 33] }, o($V3, [2, 5]), o($V3, [2, 6]), o($V3, [2, 14]), o($V6, $V7), o($V3, [2, 15]), o($V5, [2, 20])],\r\n        defaultActions: { 11: [2, 2], 24: [2, 1] },\r\n        parseError: function parseError(str, hash) {\r\n            if (hash.recoverable) {\r\n                this.trace(str);\r\n            }\r\n            else {\r\n                var error = new Error(str);\r\n                error.hash = hash;\r\n                throw error;\r\n            }\r\n        },\r\n        parse: function parse(input) {\r\n            var self = this, stack = [0], tstack = [], // token stack\r\n            vstack = [null], // semantic value stack\r\n            lstack = [], // location stack\r\n            table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\r\n            var args = lstack.slice.call(arguments, 1);\r\n            //this.reductionCount = this.shiftCount = 0;\r\n            var lexer = Object.create(this.lexer);\r\n            var sharedState = { yy: {} };\r\n            // copy state\r\n            for (var k in this.yy) {\r\n                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\r\n                    sharedState.yy[k] = this.yy[k];\r\n                }\r\n            }\r\n            lexer.setInput(input, sharedState.yy);\r\n            sharedState.yy.lexer = lexer;\r\n            sharedState.yy.parser = this;\r\n            if (typeof lexer.yylloc == 'undefined') {\r\n                lexer.yylloc = {};\r\n            }\r\n            var yyloc = lexer.yylloc;\r\n            lstack.push(yyloc);\r\n            var ranges = lexer.options && lexer.options.ranges;\r\n            if (typeof sharedState.yy.parseError === 'function') {\r\n                this.parseError = sharedState.yy.parseError;\r\n            }\r\n            else {\r\n                this.parseError = Object.getPrototypeOf(this).parseError;\r\n            }\r\n            function popStack(n) {\r\n                stack.length = stack.length - 2 * n;\r\n                vstack.length = vstack.length - n;\r\n                lstack.length = lstack.length - n;\r\n            }\r\n            _token_stack: var lex = function () {\r\n                var token;\r\n                token = lexer.lex() || EOF;\r\n                // if token isn't its numeric value, convert\r\n                if (typeof token !== 'number') {\r\n                    token = self.symbols_[token] || token;\r\n                }\r\n                return token;\r\n            };\r\n            var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\r\n            while (true) {\r\n                // retreive state number from top of stack\r\n                state = stack[stack.length - 1];\r\n                // use default actions if available\r\n                if (this.defaultActions[state]) {\r\n                    action = this.defaultActions[state];\r\n                }\r\n                else {\r\n                    if (symbol === null || typeof symbol == 'undefined') {\r\n                        symbol = lex();\r\n                    }\r\n                    // read action for current state and first input\r\n                    action = table[state] && table[state][symbol];\r\n                }\r\n                _handle_error: \r\n                // handle parse error\r\n                if (typeof action === 'undefined' || !action.length || !action[0]) {\r\n                    var error_rule_depth;\r\n                    var errStr = '';\r\n                    // Return the rule stack depth where the nearest error rule can be found.\r\n                    // Return FALSE when no error recovery rule was found.\r\n                    function locateNearestErrorRecoveryRule(state) {\r\n                        var stack_probe = stack.length - 1;\r\n                        var depth = 0;\r\n                        // try to recover from error\r\n                        for (;;) {\r\n                            // check for error recovery rule in this state\r\n                            if ((TERROR.toString()) in table[state]) {\r\n                                return depth;\r\n                            }\r\n                            if (state === 0 || stack_probe < 2) {\r\n                                return false; // No suitable error recovery rule available.\r\n                            }\r\n                            stack_probe -= 2; // popStack(1): [symbol, action]\r\n                            state = stack[stack_probe];\r\n                            ++depth;\r\n                        }\r\n                    }\r\n                    if (!recovering) {\r\n                        // first see if there's any chance at hitting an error recovery rule:\r\n                        error_rule_depth = locateNearestErrorRecoveryRule(state);\r\n                        // Report error\r\n                        expected = [];\r\n                        for (p in table[state]) {\r\n                            if (this.terminals_[p] && p > TERROR) {\r\n                                expected.push(\"'\" + this.terminals_[p] + \"'\");\r\n                            }\r\n                        }\r\n                        if (lexer.showPosition) {\r\n                            errStr = 'Parse error on line ' + (yylineno + 1) + \":\\n\" + lexer.showPosition() + \"\\nExpecting \" + expected.join(', ') + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\r\n                        }\r\n                        else {\r\n                            errStr = 'Parse error on line ' + (yylineno + 1) + \": Unexpected \" +\r\n                                (symbol == EOF ? \"end of input\" :\r\n                                    (\"'\" + (this.terminals_[symbol] || symbol) + \"'\"));\r\n                        }\r\n                        this.parseError(errStr, {\r\n                            text: lexer.match,\r\n                            token: this.terminals_[symbol] || symbol,\r\n                            line: lexer.yylineno,\r\n                            loc: yyloc,\r\n                            expected: expected,\r\n                            recoverable: (error_rule_depth !== false)\r\n                        });\r\n                    }\r\n                    else if (preErrorSymbol !== EOF) {\r\n                        error_rule_depth = locateNearestErrorRecoveryRule(state);\r\n                    }\r\n                    // just recovered from another error\r\n                    if (recovering == 3) {\r\n                        if (symbol === EOF || preErrorSymbol === EOF) {\r\n                            throw new Error(errStr || 'Parsing halted while starting to recover from another error.');\r\n                        }\r\n                        // discard current lookahead and grab another\r\n                        yyleng = lexer.yyleng;\r\n                        yytext = lexer.yytext;\r\n                        yylineno = lexer.yylineno;\r\n                        yyloc = lexer.yylloc;\r\n                        symbol = lex();\r\n                    }\r\n                    // try to recover from error\r\n                    if (error_rule_depth === false) {\r\n                        throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');\r\n                    }\r\n                    popStack(error_rule_depth);\r\n                    preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token\r\n                    symbol = TERROR; // insert generic error symbol as new lookahead\r\n                    state = stack[stack.length - 1];\r\n                    action = table[state] && table[state][TERROR];\r\n                    recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\r\n                }\r\n                // this shouldn't happen, unless resolve defaults are off\r\n                if (action[0] instanceof Array && action.length > 1) {\r\n                    throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\r\n                }\r\n                switch (action[0]) {\r\n                    case 1: // shift\r\n                        //this.shiftCount++;\r\n                        stack.push(symbol);\r\n                        vstack.push(lexer.yytext);\r\n                        lstack.push(lexer.yylloc);\r\n                        stack.push(action[1]); // push state\r\n                        symbol = null;\r\n                        if (!preErrorSymbol) { // normal execution/no error\r\n                            yyleng = lexer.yyleng;\r\n                            yytext = lexer.yytext;\r\n                            yylineno = lexer.yylineno;\r\n                            yyloc = lexer.yylloc;\r\n                            if (recovering > 0) {\r\n                                recovering--;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // error just occurred, resume old lookahead f/ before error\r\n                            symbol = preErrorSymbol;\r\n                            preErrorSymbol = null;\r\n                        }\r\n                        break;\r\n                    case 2:\r\n                        // reduce\r\n                        //this.reductionCount++;\r\n                        len = this.productions_[action[1]][1];\r\n                        // perform semantic action\r\n                        yyval.$ = vstack[vstack.length - len]; // default to $$ = $1\r\n                        // default location, uses first token for firsts, last for lasts\r\n                        yyval._$ = {\r\n                            first_line: lstack[lstack.length - (len || 1)].first_line,\r\n                            last_line: lstack[lstack.length - 1].last_line,\r\n                            first_column: lstack[lstack.length - (len || 1)].first_column,\r\n                            last_column: lstack[lstack.length - 1].last_column\r\n                        };\r\n                        if (ranges) {\r\n                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\r\n                        }\r\n                        r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));\r\n                        if (typeof r !== 'undefined') {\r\n                            return r;\r\n                        }\r\n                        // pop off stack\r\n                        if (len) {\r\n                            stack = stack.slice(0, -1 * len * 2);\r\n                            vstack = vstack.slice(0, -1 * len);\r\n                            lstack = lstack.slice(0, -1 * len);\r\n                        }\r\n                        stack.push(this.productions_[action[1]][0]); // push nonterminal (reduce)\r\n                        vstack.push(yyval.$);\r\n                        lstack.push(yyval._$);\r\n                        // goto new state = table[STATE][NONTERMINAL]\r\n                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\r\n                        stack.push(newState);\r\n                        break;\r\n                    case 3:\r\n                        // accept\r\n                        return true;\r\n                }\r\n            }\r\n            return true;\r\n        } };\r\n    const { EtiquetaDoble } = require('../Xml/EtiquetaDoble');\r\n    const { EtiquetaSimple } = require('../Xml/EtiquetaSimple');\r\n    const { EtiquetaInicio } = require('../Xml/EtiquetaInicio');\r\n    const { Atributo } = require('../Xml/Atributo');\r\n    const { XmlResultado } = require('../Xml/XmlResultado');\r\n    const { ControlError } = require('../Xpath/ControlError');\r\n    const { TipoSeleccion } = require('../Xpath/TipoSeleccion');\r\n    const { ReporteGramatica } = require('../Reportes/ReporteGramatica');\r\n    let idSent = 1;\r\n    function getId() {\r\n        idSent += 100;\r\n        return idSent;\r\n    }\r\n    function formatTagName(AbreTagApertura) {\r\n        return AbreTagApertura.substring(1, AbreTagApertura.length);\r\n    }\r\n    /* generated by jison-lex 0.3.4 */\r\n    var lexer = (function () {\r\n        var lexer = ({\r\n            EOF: 1,\r\n            parseError: function parseError(str, hash) {\r\n                if (this.yy.parser) {\r\n                    this.yy.parser.parseError(str, hash);\r\n                }\r\n                else {\r\n                    throw new Error(str);\r\n                }\r\n            },\r\n            // resets the lexer, sets new input\r\n            setInput: function (input, yy) {\r\n                this.yy = yy || this.yy || {};\r\n                this._input = input;\r\n                this._more = this._backtrack = this.done = false;\r\n                this.yylineno = this.yyleng = 0;\r\n                this.yytext = this.matched = this.match = '';\r\n                this.conditionStack = ['INITIAL'];\r\n                this.yylloc = {\r\n                    first_line: 1,\r\n                    first_column: 0,\r\n                    last_line: 1,\r\n                    last_column: 0\r\n                };\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [0, 0];\r\n                }\r\n                this.offset = 0;\r\n                return this;\r\n            },\r\n            // consumes and returns one char from the input\r\n            input: function () {\r\n                var ch = this._input[0];\r\n                this.yytext += ch;\r\n                this.yyleng++;\r\n                this.offset++;\r\n                this.match += ch;\r\n                this.matched += ch;\r\n                var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\r\n                if (lines) {\r\n                    this.yylineno++;\r\n                    this.yylloc.last_line++;\r\n                }\r\n                else {\r\n                    this.yylloc.last_column++;\r\n                }\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range[1]++;\r\n                }\r\n                this._input = this._input.slice(1);\r\n                return ch;\r\n            },\r\n            // unshifts one char (or a string) into the input\r\n            unput: function (ch) {\r\n                var len = ch.length;\r\n                var lines = ch.split(/(?:\\r\\n?|\\n)/g);\r\n                this._input = ch + this._input;\r\n                this.yytext = this.yytext.substr(0, this.yytext.length - len);\r\n                //this.yyleng -= len;\r\n                this.offset -= len;\r\n                var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\r\n                this.match = this.match.substr(0, this.match.length - 1);\r\n                this.matched = this.matched.substr(0, this.matched.length - 1);\r\n                if (lines.length - 1) {\r\n                    this.yylineno -= lines.length - 1;\r\n                }\r\n                var r = this.yylloc.range;\r\n                this.yylloc = {\r\n                    first_line: this.yylloc.first_line,\r\n                    last_line: this.yylineno + 1,\r\n                    first_column: this.yylloc.first_column,\r\n                    last_column: lines ?\r\n                        (lines.length === oldLines.length ? this.yylloc.first_column : 0)\r\n                            + oldLines[oldLines.length - lines.length].length - lines[0].length :\r\n                        this.yylloc.first_column - len\r\n                };\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];\r\n                }\r\n                this.yyleng = this.yytext.length;\r\n                return this;\r\n            },\r\n            // When called from action, caches matched text and appends it on next action\r\n            more: function () {\r\n                this._more = true;\r\n                return this;\r\n            },\r\n            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\r\n            reject: function () {\r\n                if (this.options.backtrack_lexer) {\r\n                    this._backtrack = true;\r\n                }\r\n                else {\r\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\r\n                        text: \"\",\r\n                        token: null,\r\n                        line: this.yylineno\r\n                    });\r\n                }\r\n                return this;\r\n            },\r\n            // retain first n characters of the match\r\n            less: function (n) {\r\n                this.unput(this.match.slice(n));\r\n            },\r\n            // displays already matched input, i.e. for error messages\r\n            pastInput: function () {\r\n                var past = this.matched.substr(0, this.matched.length - this.match.length);\r\n                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\\n/g, \"\");\r\n            },\r\n            // displays upcoming input, i.e. for error messages\r\n            upcomingInput: function () {\r\n                var next = this.match;\r\n                if (next.length < 20) {\r\n                    next += this._input.substr(0, 20 - next.length);\r\n                }\r\n                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\r\n            },\r\n            // displays the character position where the lexing error occurred, i.e. for error messages\r\n            showPosition: function () {\r\n                var pre = this.pastInput();\r\n                var c = new Array(pre.length + 1).join(\"-\");\r\n                return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\r\n            },\r\n            // test the lexed token: return FALSE when not a match, otherwise return token\r\n            test_match: function (match, indexed_rule) {\r\n                var token, lines, backup;\r\n                if (this.options.backtrack_lexer) {\r\n                    // save context\r\n                    backup = {\r\n                        yylineno: this.yylineno,\r\n                        yylloc: {\r\n                            first_line: this.yylloc.first_line,\r\n                            last_line: this.last_line,\r\n                            first_column: this.yylloc.first_column,\r\n                            last_column: this.yylloc.last_column\r\n                        },\r\n                        yytext: this.yytext,\r\n                        match: this.match,\r\n                        matches: this.matches,\r\n                        matched: this.matched,\r\n                        yyleng: this.yyleng,\r\n                        offset: this.offset,\r\n                        _more: this._more,\r\n                        _input: this._input,\r\n                        yy: this.yy,\r\n                        conditionStack: this.conditionStack.slice(0),\r\n                        done: this.done\r\n                    };\r\n                    if (this.options.ranges) {\r\n                        backup.yylloc.range = this.yylloc.range.slice(0);\r\n                    }\r\n                }\r\n                lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\r\n                if (lines) {\r\n                    this.yylineno += lines.length;\r\n                }\r\n                this.yylloc = {\r\n                    first_line: this.yylloc.last_line,\r\n                    last_line: this.yylineno + 1,\r\n                    first_column: this.yylloc.last_column,\r\n                    last_column: lines ?\r\n                        lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\r\n                        this.yylloc.last_column + match[0].length\r\n                };\r\n                this.yytext += match[0];\r\n                this.match += match[0];\r\n                this.matches = match;\r\n                this.yyleng = this.yytext.length;\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [this.offset, this.offset += this.yyleng];\r\n                }\r\n                this._more = false;\r\n                this._backtrack = false;\r\n                this._input = this._input.slice(match[0].length);\r\n                this.matched += match[0];\r\n                token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\r\n                if (this.done && this._input) {\r\n                    this.done = false;\r\n                }\r\n                if (token) {\r\n                    return token;\r\n                }\r\n                else if (this._backtrack) {\r\n                    // recover context\r\n                    for (var k in backup) {\r\n                        this[k] = backup[k];\r\n                    }\r\n                    return false; // rule action called reject() implying the next rule should be tested instead.\r\n                }\r\n                return false;\r\n            },\r\n            // return next match in input\r\n            next: function () {\r\n                if (this.done) {\r\n                    return this.EOF;\r\n                }\r\n                if (!this._input) {\r\n                    this.done = true;\r\n                }\r\n                var token, match, tempMatch, index;\r\n                if (!this._more) {\r\n                    this.yytext = '';\r\n                    this.match = '';\r\n                }\r\n                var rules = this._currentRules();\r\n                for (var i = 0; i < rules.length; i++) {\r\n                    tempMatch = this._input.match(this.rules[rules[i]]);\r\n                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\r\n                        match = tempMatch;\r\n                        index = i;\r\n                        if (this.options.backtrack_lexer) {\r\n                            token = this.test_match(tempMatch, rules[i]);\r\n                            if (token !== false) {\r\n                                return token;\r\n                            }\r\n                            else if (this._backtrack) {\r\n                                match = false;\r\n                                continue; // rule action called reject() implying a rule MISmatch.\r\n                            }\r\n                            else {\r\n                                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n                                return false;\r\n                            }\r\n                        }\r\n                        else if (!this.options.flex) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (match) {\r\n                    token = this.test_match(match, rules[index]);\r\n                    if (token !== false) {\r\n                        return token;\r\n                    }\r\n                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n                    return false;\r\n                }\r\n                if (this._input === \"\") {\r\n                    return this.EOF;\r\n                }\r\n                else {\r\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\r\n                        text: \"\",\r\n                        token: null,\r\n                        line: this.yylineno\r\n                    });\r\n                }\r\n            },\r\n            // return next match that has a token\r\n            lex: function lex() {\r\n                var r = this.next();\r\n                if (r) {\r\n                    return r;\r\n                }\r\n                else {\r\n                    return this.lex();\r\n                }\r\n            },\r\n            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\r\n            begin: function begin(condition) {\r\n                this.conditionStack.push(condition);\r\n            },\r\n            // pop the previously active lexer condition state off the condition stack\r\n            popState: function popState() {\r\n                var n = this.conditionStack.length - 1;\r\n                if (n > 0) {\r\n                    return this.conditionStack.pop();\r\n                }\r\n                else {\r\n                    return this.conditionStack[0];\r\n                }\r\n            },\r\n            // produce the lexer rule set which is active for the currently active lexer condition state\r\n            _currentRules: function _currentRules() {\r\n                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\r\n                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\r\n                }\r\n                else {\r\n                    return this.conditions[\"INITIAL\"].rules;\r\n                }\r\n            },\r\n            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\r\n            topState: function topState(n) {\r\n                n = this.conditionStack.length - 1 - Math.abs(n || 0);\r\n                if (n >= 0) {\r\n                    return this.conditionStack[n];\r\n                }\r\n                else {\r\n                    return \"INITIAL\";\r\n                }\r\n            },\r\n            // alias for begin(condition)\r\n            pushState: function pushState(condition) {\r\n                this.begin(condition);\r\n            },\r\n            // return the number of states currently on the stack\r\n            stateStackSize: function stateStackSize() {\r\n                return this.conditionStack.length;\r\n            },\r\n            options: { \"case-insensitive\": true },\r\n            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\r\n                var YYSTATE = YY_START;\r\n                switch ($avoiding_name_collisions) {\r\n                    case 0:\r\n                        this.begin(\"Comentario\");\r\n                        break;\r\n                    case 1:\r\n                        break;\r\n                    case 2:\r\n                        break;\r\n                    case 3:\r\n                        this.popState();\r\n                        break;\r\n                    case 4:\r\n                        break;\r\n                    case 5:\r\n                        this.begin(\"TagApertura\");\r\n                        return 19;\r\n                        break;\r\n                    case 6:\r\n                        break;\r\n                    case 7:\r\n                        return 22;\r\n                        break;\r\n                    case 8:\r\n                        return 23;\r\n                        break;\r\n                    case 9:\r\n                        return 24;\r\n                        break;\r\n                    case 10:\r\n                        this.popState();\r\n                        return 20;\r\n                        break;\r\n                    case 11:\r\n                        this.begin(\"TagApertura\");\r\n                        return 12;\r\n                        break;\r\n                    case 12:\r\n                        break;\r\n                    case 13:\r\n                        return 22;\r\n                        break;\r\n                    case 14:\r\n                        return 23;\r\n                        break;\r\n                    case 15:\r\n                        return 24;\r\n                        break;\r\n                    case 16:\r\n                        this.popState();\r\n                        return 14;\r\n                        break;\r\n                    case 17:\r\n                        this.popState();\r\n                        return 18;\r\n                        break;\r\n                    case 18:\r\n                        this.begin(\"TagCierre\");\r\n                        return 16;\r\n                        break;\r\n                    case 19:\r\n                        this.popState();\r\n                        return 17;\r\n                        break;\r\n                    case 20:\r\n                        break;\r\n                    case 21:\r\n                        return 10;\r\n                        break;\r\n                    case 22:\r\n                        return 6;\r\n                        break;\r\n                    case 23:\r\n                        $$ = listaError.push(new ControlError(yy_.yytext, TipoSeleccion.ERROR_SINTACTICO, this._$.first_line, this._$.first_column, \"XPathAscendente\"));\r\n                        break;\r\n                }\r\n            },\r\n            rules: [/^(?:<!--)/i, /^(?:[\\r\\t\\&\\$\\@\\#\\?\\\\\\{\\}\\(\\)\\,\\.]+)/i, /^(?:\\n)/i, /^(?:-->)/i, /^(?:[^\"-->\"]+)/i, /^(?:<\\?xml\\b)/i, /^(?:[\\s\\r\\t\\n]+)/i, /^(?:[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:=)/i, /^(?:\"[^\\\"\\n]*\")/i, /^(?:\\?>)/i, /^(?:<[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:[\\s\\r\\t\\n]+)/i, /^(?:[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:=)/i, /^(?:\"[^\\\"\\n]*\")/i, /^(?:>)/i, /^(?:\\/>)/i, /^(?:<\\/[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:>)/i, /^(?:[\\s\\r\\t\\n]+)/i, /^(?:[^<]+)/i, /^(?:$)/i, /^(?:.)/i],\r\n            conditions: { \"TagCierre\": { \"rules\": [19], \"inclusive\": false }, \"TagApertura\": { \"rules\": [6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17], \"inclusive\": false }, \"Comentario\": { \"rules\": [1, 2, 3, 4], \"inclusive\": false }, \"INITIAL\": { \"rules\": [0, 5, 11, 18, 20, 21, 22, 23], \"inclusive\": true } }\r\n        });\r\n        return lexer;\r\n    })();\r\n    parser.lexer = lexer;\r\n    function Parser() {\r\n        this.yy = {};\r\n    }\r\n    Parser.prototype = parser;\r\n    parser.Parser = Parser;\r\n    return new Parser;\r\n})();\r\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\r\n    exports.parser = xmlA;\r\n    exports.Parser = xmlA.Parser;\r\n    exports.parse = function () { return xmlA.parse.apply(xmlA, arguments); };\r\n    exports.main = function commonjsMain(args) {\r\n        if (!args[1]) {\r\n            console.log('Usage: ' + args[0] + ' FILE');\r\n            process.exit(1);\r\n        }\r\n        var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\r\n        return exports.parser.parse(source);\r\n    };\r\n    if (typeof module !== 'undefined' && require.main === module) {\r\n        exports.main(process.argv.slice(1));\r\n    }\r\n}\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TipoSeleccion;\r\n(function (TipoSeleccion) {\r\n    TipoSeleccion[\"ACCESO_NODO_RAIZ\"] = \"ACCESO_NODO_RAIZ\";\r\n    TipoSeleccion[\"SELECT_NODOS_FROM_NODO\"] = \"SELECT_NODOS_FROM_NODO\";\r\n    TipoSeleccion[\"ERROR_SINTACTICO\"] = \"ERROR_SINTACTICO\";\r\n    TipoSeleccion[\"ERROR_LEXICO\"] = \"ERROR_LEXICO\";\r\n    TipoSeleccion[\"ERROR_SEMANTICO\"] = \"ERROR_SEMANTICO\";\r\n})(TipoSeleccion = exports.TipoSeleccion || (exports.TipoSeleccion = {}));\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Tipos;\r\n(function (Tipos) {\r\n    Tipos[\"ETIQUETA_DOBLE\"] = \"ETIQUETA_DOBLE\";\r\n    Tipos[\"ETIQUETA_SIMPLE\"] = \"ETIQUETA_SIMPLE\";\r\n    Tipos[\"ETIQUETA_UNICA\"] = \"ETIQUETA_UNICA\";\r\n    Tipos[\"ATRIBUTO\"] = \"ATRIBUTO\";\r\n    Tipos[\"VALOR\"] = \"VALOR\";\r\n})(Tipos = exports.Tipos || (exports.Tipos = {}));\r\n","/* parser generated by jison 0.4.18 */\r\n/*\r\n  Returns a Parser object of the following structure:\r\n\r\n  Parser: {\r\n    yy: {}\r\n  }\r\n\r\n  Parser.prototype: {\r\n    yy: {},\r\n    trace: function(),\r\n    symbols_: {associative list: name ==> number},\r\n    terminals_: {associative list: number ==> name},\r\n    productions_: [...],\r\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\r\n    table: [...],\r\n    defaultActions: {...},\r\n    parseError: function(str, hash),\r\n    parse: function(input),\r\n\r\n    lexer: {\r\n        EOF: 1,\r\n        parseError: function(str, hash),\r\n        setInput: function(input),\r\n        input: function(),\r\n        unput: function(str),\r\n        more: function(),\r\n        less: function(n),\r\n        pastInput: function(),\r\n        upcomingInput: function(),\r\n        showPosition: function(),\r\n        test_match: function(regex_match_array, rule_index),\r\n        next: function(),\r\n        lex: function(),\r\n        begin: function(condition),\r\n        popState: function(),\r\n        _currentRules: function(),\r\n        topState: function(),\r\n        pushState: function(condition),\r\n\r\n        options: {\r\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\r\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\r\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\r\n        },\r\n\r\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\r\n        rules: [...],\r\n        conditions: {associative list: name ==> set},\r\n    }\r\n  }\r\n\r\n\r\n  token location info (@$, _$, etc.): {\r\n    first_line: n,\r\n    last_line: n,\r\n    first_column: n,\r\n    last_column: n,\r\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\r\n  }\r\n\r\n\r\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\r\n    text:        (matched text)\r\n    token:       (the produced terminal token, if any)\r\n    line:        (yylineno)\r\n  }\r\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\r\n    loc:         (yylloc)\r\n    expected:    (string describing the set of expected tokens)\r\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\r\n  }\r\n*/\r\nvar xpathA = (function () {\r\n    var o = function (k, v, o, l) { for (o = o || {}, l = k.length; l--; o[k[l]] = v)\r\n        ; return o; }, $V0 = [1, 7], $V1 = [1, 8], $V2 = [1, 9], $V3 = [1, 5], $V4 = [5, 6], $V5 = [2, 5, 6, 10, 11, 12], $V6 = [2, 5, 6, 10, 11, 12, 14, 15, 16, 17], $V7 = [1, 25], $V8 = [1, 26], $V9 = [1, 31], $Va = [1, 30], $Vb = [10, 17, 20, 21, 22], $Vc = [20, 21, 22];\r\n    var parser = { trace: function trace() { },\r\n        yy: {},\r\n        symbols_: { \"error\": 2, \"XPATH\": 3, \"CONCATENACION_SETS\": 4, \"EOF\": 5, \"barraVertical\": 6, \"LISTA_SETS\": 7, \"SET\": 8, \"SELECTOR\": 9, \"slash\": 10, \"dobleSlash\": 11, \"identificador\": 12, \"PREDICADO\": 13, \"arroba\": 14, \"dosPuntos\": 15, \"punto\": 16, \"asterisco\": 17, \"corecheteA\": 18, \"OPERACION\": 19, \"corcheteC\": 20, \"mas\": 21, \"menos\": 22, \"entero\": 23, \"decimal\": 24, \"$accept\": 0, \"$end\": 1 },\r\n        terminals_: { 2: \"error\", 5: \"EOF\", 6: \"barraVertical\", 10: \"slash\", 11: \"dobleSlash\", 12: \"identificador\", 14: \"arroba\", 15: \"dosPuntos\", 16: \"punto\", 17: \"asterisco\", 18: \"corecheteA\", 20: \"corcheteC\", 21: \"mas\", 22: \"menos\", 23: \"entero\", 24: \"decimal\" },\r\n        productions_: [0, [3, 2], [4, 3], [4, 1], [7, 2], [7, 1], [9, 1], [9, 1], [8, 1], [8, 2], [8, 3], [8, 3], [8, 2], [8, 2], [8, 3], [8, 2], [8, 2], [13, 3], [19, 3], [19, 3], [19, 3], [19, 3], [19, 1], [19, 1]],\r\n        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\r\n            /* this == yyval */\r\n            var $0 = $$.length - 1;\r\n            switch (yystate) {\r\n                case 1:\r\n                    return $$[$0 - 1];\r\n                    break;\r\n                case 2:\r\n                    $$[$0 - 2].push($$[$0]);\r\n                    this.$ = $$[$0 - 2];\r\n                    break;\r\n                case 3:\r\n                    this.$ = [$$[$0]];\r\n                    break;\r\n                case 4:\r\n                    aux = $$[$0 - 1];\r\n                    while (aux.next != null) {\r\n                        aux = aux.next;\r\n                    }\r\n                    ;\r\n                    aux.next = $$[$0];\r\n                    this.$ = $$[$0 - 1];\r\n                    break;\r\n                case 5:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 6:\r\n                case 7:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 8:\r\n                    this.$ = { tipo: TipoSeleccion.ACCESO_NODO_RAIZ, id: $$[$0], next: null };\r\n                    break;\r\n                case 9:\r\n                    this.$ = { tipo: TipoSeleccion.SELECT_NODOS_FROM_NODO, selector: $$[$0 - 1], id: $$[$0], predicado: null, next: null };\r\n                    break;\r\n                case 10:\r\n                    this.$ = { tipo: TipoSeleccion.SELECT_NODOS_FROM_NODO, selector: $$[$0 - 2], id: $$[$0 - 1], predicado: $$[$0], next: null };\r\n                    break;\r\n                case 16:\r\n                    this.$ = new ControlError(yytext, TipoSeleccion.ERROR_SINTACTICO, this._$.first_line, this._$.first_column, \"XPathAscendente\");\r\n                    break;\r\n                case 17:\r\n                    this.$ = $$[$0 - 1];\r\n                    break;\r\n                case 18:\r\n                    this.$ = new OpBinaria($$[$0 - 2], $$[$0], TiposOp.SUMA);\r\n                    break;\r\n                case 19:\r\n                    this.$ = new OpBinaria($$[$0 - 2], $$[$0], TiposOp.RESTA);\r\n                    break;\r\n                case 20:\r\n                    this.$ = new OpBinaria($$[$0 - 2], $$[$0], TiposOp.MULTIPLICACION);\r\n                    break;\r\n                case 21:\r\n                    this.$ = new OpBinaria($$[$0 - 2], $$[$0], TiposOp.DIVISION);\r\n                    break;\r\n                case 22:\r\n                    this.$ = new Primitivo(parseInt($$[$0]), TipoVal.ENTERO);\r\n                    break;\r\n                case 23:\r\n                    this.$ = new Primitivo(parseFloat($$[$0]), TipoVal.DECIMAL);\r\n                    break;\r\n            }\r\n        },\r\n        table: [{ 2: $V0, 3: 1, 4: 2, 7: 3, 8: 4, 9: 6, 10: $V1, 11: $V2, 12: $V3 }, { 1: [3] }, { 5: [1, 10], 6: [1, 11] }, o($V4, [2, 3], { 9: 6, 8: 12, 2: $V0, 10: $V1, 11: $V2, 12: $V3 }), o($V5, [2, 5]), o($V5, [2, 8]), { 12: [1, 13], 14: [1, 14], 15: [1, 15], 16: [1, 16], 17: [1, 17] }, { 9: 18, 10: $V1, 11: $V2 }, o($V6, [2, 6]), o($V6, [2, 7]), { 1: [2, 1] }, { 2: $V0, 7: 19, 8: 4, 9: 6, 10: $V1, 11: $V2, 12: $V3 }, o($V5, [2, 4]), o($V5, [2, 9], { 13: 20, 18: [1, 21] }), { 12: [1, 22], 17: [1, 23] }, o($V5, [2, 12]), o($V5, [2, 13]), o($V5, [2, 15]), o($V5, [2, 16]), o($V4, [2, 2], { 9: 6, 8: 12, 2: $V0, 10: $V1, 11: $V2, 12: $V3 }), o($V5, [2, 10]), { 19: 24, 23: $V7, 24: $V8 }, o($V5, [2, 11]), o($V5, [2, 14]), { 10: $V9, 17: $Va, 20: [1, 27], 21: [1, 28], 22: [1, 29] }, o($Vb, [2, 22]), o($Vb, [2, 23]), o($V5, [2, 17]), { 19: 32, 23: $V7, 24: $V8 }, { 19: 33, 23: $V7, 24: $V8 }, { 19: 34, 23: $V7, 24: $V8 }, { 19: 35, 23: $V7, 24: $V8 }, o($Vc, [2, 18], { 10: $V9, 17: $Va }), o($Vc, [2, 19], { 10: $V9, 17: $Va }), o($Vb, [2, 20]), o($Vb, [2, 21])],\r\n        defaultActions: { 10: [2, 1] },\r\n        parseError: function parseError(str, hash) {\r\n            if (hash.recoverable) {\r\n                this.trace(str);\r\n            }\r\n            else {\r\n                var error = new Error(str);\r\n                error.hash = hash;\r\n                throw error;\r\n            }\r\n        },\r\n        parse: function parse(input) {\r\n            var self = this, stack = [0], tstack = [], // token stack\r\n            vstack = [null], // semantic value stack\r\n            lstack = [], // location stack\r\n            table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\r\n            var args = lstack.slice.call(arguments, 1);\r\n            //this.reductionCount = this.shiftCount = 0;\r\n            var lexer = Object.create(this.lexer);\r\n            var sharedState = { yy: {} };\r\n            // copy state\r\n            for (var k in this.yy) {\r\n                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\r\n                    sharedState.yy[k] = this.yy[k];\r\n                }\r\n            }\r\n            lexer.setInput(input, sharedState.yy);\r\n            sharedState.yy.lexer = lexer;\r\n            sharedState.yy.parser = this;\r\n            if (typeof lexer.yylloc == 'undefined') {\r\n                lexer.yylloc = {};\r\n            }\r\n            var yyloc = lexer.yylloc;\r\n            lstack.push(yyloc);\r\n            var ranges = lexer.options && lexer.options.ranges;\r\n            if (typeof sharedState.yy.parseError === 'function') {\r\n                this.parseError = sharedState.yy.parseError;\r\n            }\r\n            else {\r\n                this.parseError = Object.getPrototypeOf(this).parseError;\r\n            }\r\n            function popStack(n) {\r\n                stack.length = stack.length - 2 * n;\r\n                vstack.length = vstack.length - n;\r\n                lstack.length = lstack.length - n;\r\n            }\r\n            _token_stack: var lex = function () {\r\n                var token;\r\n                token = lexer.lex() || EOF;\r\n                // if token isn't its numeric value, convert\r\n                if (typeof token !== 'number') {\r\n                    token = self.symbols_[token] || token;\r\n                }\r\n                return token;\r\n            };\r\n            var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\r\n            while (true) {\r\n                // retreive state number from top of stack\r\n                state = stack[stack.length - 1];\r\n                // use default actions if available\r\n                if (this.defaultActions[state]) {\r\n                    action = this.defaultActions[state];\r\n                }\r\n                else {\r\n                    if (symbol === null || typeof symbol == 'undefined') {\r\n                        symbol = lex();\r\n                    }\r\n                    // read action for current state and first input\r\n                    action = table[state] && table[state][symbol];\r\n                }\r\n                _handle_error: \r\n                // handle parse error\r\n                if (typeof action === 'undefined' || !action.length || !action[0]) {\r\n                    var error_rule_depth;\r\n                    var errStr = '';\r\n                    // Return the rule stack depth where the nearest error rule can be found.\r\n                    // Return FALSE when no error recovery rule was found.\r\n                    function locateNearestErrorRecoveryRule(state) {\r\n                        var stack_probe = stack.length - 1;\r\n                        var depth = 0;\r\n                        // try to recover from error\r\n                        for (;;) {\r\n                            // check for error recovery rule in this state\r\n                            if ((TERROR.toString()) in table[state]) {\r\n                                return depth;\r\n                            }\r\n                            if (state === 0 || stack_probe < 2) {\r\n                                return false; // No suitable error recovery rule available.\r\n                            }\r\n                            stack_probe -= 2; // popStack(1): [symbol, action]\r\n                            state = stack[stack_probe];\r\n                            ++depth;\r\n                        }\r\n                    }\r\n                    if (!recovering) {\r\n                        // first see if there's any chance at hitting an error recovery rule:\r\n                        error_rule_depth = locateNearestErrorRecoveryRule(state);\r\n                        // Report error\r\n                        expected = [];\r\n                        for (p in table[state]) {\r\n                            if (this.terminals_[p] && p > TERROR) {\r\n                                expected.push(\"'\" + this.terminals_[p] + \"'\");\r\n                            }\r\n                        }\r\n                        if (lexer.showPosition) {\r\n                            errStr = 'Parse error on line ' + (yylineno + 1) + \":\\n\" + lexer.showPosition() + \"\\nExpecting \" + expected.join(', ') + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\r\n                        }\r\n                        else {\r\n                            errStr = 'Parse error on line ' + (yylineno + 1) + \": Unexpected \" +\r\n                                (symbol == EOF ? \"end of input\" :\r\n                                    (\"'\" + (this.terminals_[symbol] || symbol) + \"'\"));\r\n                        }\r\n                        this.parseError(errStr, {\r\n                            text: lexer.match,\r\n                            token: this.terminals_[symbol] || symbol,\r\n                            line: lexer.yylineno,\r\n                            loc: yyloc,\r\n                            expected: expected,\r\n                            recoverable: (error_rule_depth !== false)\r\n                        });\r\n                    }\r\n                    else if (preErrorSymbol !== EOF) {\r\n                        error_rule_depth = locateNearestErrorRecoveryRule(state);\r\n                    }\r\n                    // just recovered from another error\r\n                    if (recovering == 3) {\r\n                        if (symbol === EOF || preErrorSymbol === EOF) {\r\n                            throw new Error(errStr || 'Parsing halted while starting to recover from another error.');\r\n                        }\r\n                        // discard current lookahead and grab another\r\n                        yyleng = lexer.yyleng;\r\n                        yytext = lexer.yytext;\r\n                        yylineno = lexer.yylineno;\r\n                        yyloc = lexer.yylloc;\r\n                        symbol = lex();\r\n                    }\r\n                    // try to recover from error\r\n                    if (error_rule_depth === false) {\r\n                        throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');\r\n                    }\r\n                    popStack(error_rule_depth);\r\n                    preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token\r\n                    symbol = TERROR; // insert generic error symbol as new lookahead\r\n                    state = stack[stack.length - 1];\r\n                    action = table[state] && table[state][TERROR];\r\n                    recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\r\n                }\r\n                // this shouldn't happen, unless resolve defaults are off\r\n                if (action[0] instanceof Array && action.length > 1) {\r\n                    throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\r\n                }\r\n                switch (action[0]) {\r\n                    case 1: // shift\r\n                        //this.shiftCount++;\r\n                        stack.push(symbol);\r\n                        vstack.push(lexer.yytext);\r\n                        lstack.push(lexer.yylloc);\r\n                        stack.push(action[1]); // push state\r\n                        symbol = null;\r\n                        if (!preErrorSymbol) { // normal execution/no error\r\n                            yyleng = lexer.yyleng;\r\n                            yytext = lexer.yytext;\r\n                            yylineno = lexer.yylineno;\r\n                            yyloc = lexer.yylloc;\r\n                            if (recovering > 0) {\r\n                                recovering--;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // error just occurred, resume old lookahead f/ before error\r\n                            symbol = preErrorSymbol;\r\n                            preErrorSymbol = null;\r\n                        }\r\n                        break;\r\n                    case 2:\r\n                        // reduce\r\n                        //this.reductionCount++;\r\n                        len = this.productions_[action[1]][1];\r\n                        // perform semantic action\r\n                        yyval.$ = vstack[vstack.length - len]; // default to $$ = $1\r\n                        // default location, uses first token for firsts, last for lasts\r\n                        yyval._$ = {\r\n                            first_line: lstack[lstack.length - (len || 1)].first_line,\r\n                            last_line: lstack[lstack.length - 1].last_line,\r\n                            first_column: lstack[lstack.length - (len || 1)].first_column,\r\n                            last_column: lstack[lstack.length - 1].last_column\r\n                        };\r\n                        if (ranges) {\r\n                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\r\n                        }\r\n                        r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));\r\n                        if (typeof r !== 'undefined') {\r\n                            return r;\r\n                        }\r\n                        // pop off stack\r\n                        if (len) {\r\n                            stack = stack.slice(0, -1 * len * 2);\r\n                            vstack = vstack.slice(0, -1 * len);\r\n                            lstack = lstack.slice(0, -1 * len);\r\n                        }\r\n                        stack.push(this.productions_[action[1]][0]); // push nonterminal (reduce)\r\n                        vstack.push(yyval.$);\r\n                        lstack.push(yyval._$);\r\n                        // goto new state = table[STATE][NONTERMINAL]\r\n                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\r\n                        stack.push(newState);\r\n                        break;\r\n                    case 3:\r\n                        // accept\r\n                        return true;\r\n                }\r\n            }\r\n            return true;\r\n        } };\r\n    const { TipoSeleccion } = require('../Xpath/TipoSeleccion');\r\n    const { OpBinaria } = require('../Xpath/OpBinaria');\r\n    const { TiposOp } = require('../Xpath/TiposOp');\r\n    const { Primitivo } = require('../Xpath/Primitivo');\r\n    const { TipoVal } = require('../Xpath/TipoVal');\r\n    const { ControlError } = require('../Xpath/ControlError');\r\n    listaError = [];\r\n    /* generated by jison-lex 0.3.4 */\r\n    var lexer = (function () {\r\n        var lexer = ({\r\n            EOF: 1,\r\n            parseError: function parseError(str, hash) {\r\n                if (this.yy.parser) {\r\n                    this.yy.parser.parseError(str, hash);\r\n                }\r\n                else {\r\n                    throw new Error(str);\r\n                }\r\n            },\r\n            // resets the lexer, sets new input\r\n            setInput: function (input, yy) {\r\n                this.yy = yy || this.yy || {};\r\n                this._input = input;\r\n                this._more = this._backtrack = this.done = false;\r\n                this.yylineno = this.yyleng = 0;\r\n                this.yytext = this.matched = this.match = '';\r\n                this.conditionStack = ['INITIAL'];\r\n                this.yylloc = {\r\n                    first_line: 1,\r\n                    first_column: 0,\r\n                    last_line: 1,\r\n                    last_column: 0\r\n                };\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [0, 0];\r\n                }\r\n                this.offset = 0;\r\n                return this;\r\n            },\r\n            // consumes and returns one char from the input\r\n            input: function () {\r\n                var ch = this._input[0];\r\n                this.yytext += ch;\r\n                this.yyleng++;\r\n                this.offset++;\r\n                this.match += ch;\r\n                this.matched += ch;\r\n                var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\r\n                if (lines) {\r\n                    this.yylineno++;\r\n                    this.yylloc.last_line++;\r\n                }\r\n                else {\r\n                    this.yylloc.last_column++;\r\n                }\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range[1]++;\r\n                }\r\n                this._input = this._input.slice(1);\r\n                return ch;\r\n            },\r\n            // unshifts one char (or a string) into the input\r\n            unput: function (ch) {\r\n                var len = ch.length;\r\n                var lines = ch.split(/(?:\\r\\n?|\\n)/g);\r\n                this._input = ch + this._input;\r\n                this.yytext = this.yytext.substr(0, this.yytext.length - len);\r\n                //this.yyleng -= len;\r\n                this.offset -= len;\r\n                var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\r\n                this.match = this.match.substr(0, this.match.length - 1);\r\n                this.matched = this.matched.substr(0, this.matched.length - 1);\r\n                if (lines.length - 1) {\r\n                    this.yylineno -= lines.length - 1;\r\n                }\r\n                var r = this.yylloc.range;\r\n                this.yylloc = {\r\n                    first_line: this.yylloc.first_line,\r\n                    last_line: this.yylineno + 1,\r\n                    first_column: this.yylloc.first_column,\r\n                    last_column: lines ?\r\n                        (lines.length === oldLines.length ? this.yylloc.first_column : 0)\r\n                            + oldLines[oldLines.length - lines.length].length - lines[0].length :\r\n                        this.yylloc.first_column - len\r\n                };\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];\r\n                }\r\n                this.yyleng = this.yytext.length;\r\n                return this;\r\n            },\r\n            // When called from action, caches matched text and appends it on next action\r\n            more: function () {\r\n                this._more = true;\r\n                return this;\r\n            },\r\n            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\r\n            reject: function () {\r\n                if (this.options.backtrack_lexer) {\r\n                    this._backtrack = true;\r\n                }\r\n                else {\r\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\r\n                        text: \"\",\r\n                        token: null,\r\n                        line: this.yylineno\r\n                    });\r\n                }\r\n                return this;\r\n            },\r\n            // retain first n characters of the match\r\n            less: function (n) {\r\n                this.unput(this.match.slice(n));\r\n            },\r\n            // displays already matched input, i.e. for error messages\r\n            pastInput: function () {\r\n                var past = this.matched.substr(0, this.matched.length - this.match.length);\r\n                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\\n/g, \"\");\r\n            },\r\n            // displays upcoming input, i.e. for error messages\r\n            upcomingInput: function () {\r\n                var next = this.match;\r\n                if (next.length < 20) {\r\n                    next += this._input.substr(0, 20 - next.length);\r\n                }\r\n                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\r\n            },\r\n            // displays the character position where the lexing error occurred, i.e. for error messages\r\n            showPosition: function () {\r\n                var pre = this.pastInput();\r\n                var c = new Array(pre.length + 1).join(\"-\");\r\n                return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\r\n            },\r\n            // test the lexed token: return FALSE when not a match, otherwise return token\r\n            test_match: function (match, indexed_rule) {\r\n                var token, lines, backup;\r\n                if (this.options.backtrack_lexer) {\r\n                    // save context\r\n                    backup = {\r\n                        yylineno: this.yylineno,\r\n                        yylloc: {\r\n                            first_line: this.yylloc.first_line,\r\n                            last_line: this.last_line,\r\n                            first_column: this.yylloc.first_column,\r\n                            last_column: this.yylloc.last_column\r\n                        },\r\n                        yytext: this.yytext,\r\n                        match: this.match,\r\n                        matches: this.matches,\r\n                        matched: this.matched,\r\n                        yyleng: this.yyleng,\r\n                        offset: this.offset,\r\n                        _more: this._more,\r\n                        _input: this._input,\r\n                        yy: this.yy,\r\n                        conditionStack: this.conditionStack.slice(0),\r\n                        done: this.done\r\n                    };\r\n                    if (this.options.ranges) {\r\n                        backup.yylloc.range = this.yylloc.range.slice(0);\r\n                    }\r\n                }\r\n                lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\r\n                if (lines) {\r\n                    this.yylineno += lines.length;\r\n                }\r\n                this.yylloc = {\r\n                    first_line: this.yylloc.last_line,\r\n                    last_line: this.yylineno + 1,\r\n                    first_column: this.yylloc.last_column,\r\n                    last_column: lines ?\r\n                        lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\r\n                        this.yylloc.last_column + match[0].length\r\n                };\r\n                this.yytext += match[0];\r\n                this.match += match[0];\r\n                this.matches = match;\r\n                this.yyleng = this.yytext.length;\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [this.offset, this.offset += this.yyleng];\r\n                }\r\n                this._more = false;\r\n                this._backtrack = false;\r\n                this._input = this._input.slice(match[0].length);\r\n                this.matched += match[0];\r\n                token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\r\n                if (this.done && this._input) {\r\n                    this.done = false;\r\n                }\r\n                if (token) {\r\n                    return token;\r\n                }\r\n                else if (this._backtrack) {\r\n                    // recover context\r\n                    for (var k in backup) {\r\n                        this[k] = backup[k];\r\n                    }\r\n                    return false; // rule action called reject() implying the next rule should be tested instead.\r\n                }\r\n                return false;\r\n            },\r\n            // return next match in input\r\n            next: function () {\r\n                if (this.done) {\r\n                    return this.EOF;\r\n                }\r\n                if (!this._input) {\r\n                    this.done = true;\r\n                }\r\n                var token, match, tempMatch, index;\r\n                if (!this._more) {\r\n                    this.yytext = '';\r\n                    this.match = '';\r\n                }\r\n                var rules = this._currentRules();\r\n                for (var i = 0; i < rules.length; i++) {\r\n                    tempMatch = this._input.match(this.rules[rules[i]]);\r\n                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\r\n                        match = tempMatch;\r\n                        index = i;\r\n                        if (this.options.backtrack_lexer) {\r\n                            token = this.test_match(tempMatch, rules[i]);\r\n                            if (token !== false) {\r\n                                return token;\r\n                            }\r\n                            else if (this._backtrack) {\r\n                                match = false;\r\n                                continue; // rule action called reject() implying a rule MISmatch.\r\n                            }\r\n                            else {\r\n                                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n                                return false;\r\n                            }\r\n                        }\r\n                        else if (!this.options.flex) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (match) {\r\n                    token = this.test_match(match, rules[index]);\r\n                    if (token !== false) {\r\n                        return token;\r\n                    }\r\n                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n                    return false;\r\n                }\r\n                if (this._input === \"\") {\r\n                    return this.EOF;\r\n                }\r\n                else {\r\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\r\n                        text: \"\",\r\n                        token: null,\r\n                        line: this.yylineno\r\n                    });\r\n                }\r\n            },\r\n            // return next match that has a token\r\n            lex: function lex() {\r\n                var r = this.next();\r\n                if (r) {\r\n                    return r;\r\n                }\r\n                else {\r\n                    return this.lex();\r\n                }\r\n            },\r\n            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\r\n            begin: function begin(condition) {\r\n                this.conditionStack.push(condition);\r\n            },\r\n            // pop the previously active lexer condition state off the condition stack\r\n            popState: function popState() {\r\n                var n = this.conditionStack.length - 1;\r\n                if (n > 0) {\r\n                    return this.conditionStack.pop();\r\n                }\r\n                else {\r\n                    return this.conditionStack[0];\r\n                }\r\n            },\r\n            // produce the lexer rule set which is active for the currently active lexer condition state\r\n            _currentRules: function _currentRules() {\r\n                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\r\n                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\r\n                }\r\n                else {\r\n                    return this.conditions[\"INITIAL\"].rules;\r\n                }\r\n            },\r\n            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\r\n            topState: function topState(n) {\r\n                n = this.conditionStack.length - 1 - Math.abs(n || 0);\r\n                if (n >= 0) {\r\n                    return this.conditionStack[n];\r\n                }\r\n                else {\r\n                    return \"INITIAL\";\r\n                }\r\n            },\r\n            // alias for begin(condition)\r\n            pushState: function pushState(condition) {\r\n                this.begin(condition);\r\n            },\r\n            // return the number of states currently on the stack\r\n            stateStackSize: function stateStackSize() {\r\n                return this.conditionStack.length;\r\n            },\r\n            options: { \"case-insensitive\": true },\r\n            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\r\n                var YYSTATE = YY_START;\r\n                switch ($avoiding_name_collisions) {\r\n                    case 0:\r\n                        break;\r\n                    case 1:\r\n                        return 'menor';\r\n                        break;\r\n                    case 2:\r\n                        return 'mayor';\r\n                        break;\r\n                    case 3:\r\n                        return 11;\r\n                        break;\r\n                    case 4:\r\n                        return 10;\r\n                        break;\r\n                    case 5:\r\n                        return 'igual';\r\n                        break;\r\n                    case 6:\r\n                        return 6;\r\n                        break;\r\n                    case 7:\r\n                        return 21;\r\n                        break;\r\n                    case 8:\r\n                        return 22;\r\n                        break;\r\n                    case 9:\r\n                        return 17;\r\n                        break;\r\n                    case 10:\r\n                        return 'div';\r\n                        break;\r\n                    case 11:\r\n                        return 'noIgual';\r\n                        break;\r\n                    case 12:\r\n                        return 'mayorQue';\r\n                        break;\r\n                    case 13:\r\n                        return 'menorQue';\r\n                        break;\r\n                    case 14:\r\n                        return 'and';\r\n                        break;\r\n                    case 15:\r\n                        return 'or';\r\n                        break;\r\n                    case 16:\r\n                        return '@';\r\n                        break;\r\n                    case 17:\r\n                        return 16;\r\n                        break;\r\n                    case 18:\r\n                        return 15;\r\n                        break;\r\n                    case 19:\r\n                        return 'dobleDosPuntos';\r\n                        break;\r\n                    case 20:\r\n                        return 18;\r\n                        break;\r\n                    case 21:\r\n                        return 20;\r\n                        break;\r\n                    case 22:\r\n                        return 'parentesisA';\r\n                        break;\r\n                    case 23:\r\n                        return 'parentesisC';\r\n                        break;\r\n                    case 24:\r\n                        return 'ancestor';\r\n                        break;\r\n                    case 25:\r\n                        return 'ancestor-or-self';\r\n                        break;\r\n                    case 26:\r\n                        return 'attribute';\r\n                        break;\r\n                    case 27:\r\n                        return 'child';\r\n                        break;\r\n                    case 28:\r\n                        return 'descendant';\r\n                        break;\r\n                    case 29:\r\n                        return 'descendant-or-self';\r\n                        break;\r\n                    case 30:\r\n                        return 'following';\r\n                        break;\r\n                    case 31:\r\n                        return 'following-sibling';\r\n                        break;\r\n                    case 32:\r\n                        return \"namespace\";\r\n                        break;\r\n                    case 33:\r\n                        return 'parent';\r\n                        break;\r\n                    case 34:\r\n                        return 'preceding';\r\n                        break;\r\n                    case 35:\r\n                        return 'preceding-sibling';\r\n                        break;\r\n                    case 36:\r\n                        return 'self';\r\n                        break;\r\n                    case 37:\r\n                        return 'NODO';\r\n                        break;\r\n                    case 38:\r\n                        return 'LANG';\r\n                        break;\r\n                    case 39:\r\n                        return 'POSICION';\r\n                        break;\r\n                    case 40:\r\n                        return 'ULTIMO';\r\n                        break;\r\n                    case 41:\r\n                        return 'TEXTO';\r\n                        break;\r\n                    case 42:\r\n                        return 'CADENA';\r\n                        break;\r\n                    case 43:\r\n                        return 24;\r\n                        break;\r\n                    case 44:\r\n                        return 23;\r\n                        break;\r\n                    case 45:\r\n                        return 12;\r\n                        break;\r\n                    case 46:\r\n                        return 5;\r\n                        break;\r\n                    case 47:\r\n                        new ControlError(yy_.yytext, TipoSeleccion.ERROR_LEXICO, yy_.yylloc.first_line, yy_.yylloc.first_column, \"XpathAscendente\");\r\n                        break;\r\n                }\r\n            },\r\n            rules: [/^(?:[\\s]+)/i, /^(?:<)/i, /^(?:>)/i, /^(?:\\/\\/)/i, /^(?:\\/)/i, /^(?:=)/i, /^(?:\\|)/i, /^(?:\\+)/i, /^(?:-)/i, /^(?:\\*)/i, /^(?:div\\b)/i, /^(?:!=)/i, /^(?:>=)/i, /^(?:<=)/i, /^(?:and\\b)/i, /^(?:or\\b)/i, /^(?:@)/i, /^(?:\\.)/i, /^(?:\\.\\.)/i, /^(?:::)/i, /^(?:\\[)/i, /^(?:\\])/i, /^(?:\\()/i, /^(?:\\))/i, /^(?:ancestor\\b)/i, /^(?:ancestor-or-self\\b)/i, /^(?:attribute\\b)/i, /^(?:child\\b)/i, /^(?:descendant\\b)/i, /^(?:descendant-or-self\\b)/i, /^(?:following\\b)/i, /^(?:following-sibling\\b)/i, /^(?:namespace\\b)/i, /^(?:parent\\b)/i, /^(?:preceding\\b)/i, /^(?:preceding-sibling\\b)/i, /^(?:self\\b)/i, /^(?:node\\b)/i, /^(?:lang\\b)/i, /^(?:position\\b)/i, /^(?:last\\b)/i, /^(?:text\\b)/i, /^(?:'[^\\']*')/i, /^(?:[0-9]+(\\.[0-9]+)\\b)/i, /^(?:[0-9]+\\b)/i, /^(?:[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:$)/i, /^(?:.)/i],\r\n            conditions: { \"INITIAL\": { \"rules\": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47], \"inclusive\": true } }\r\n        });\r\n        return lexer;\r\n    })();\r\n    parser.lexer = lexer;\r\n    function Parser() {\r\n        this.yy = {};\r\n    }\r\n    Parser.prototype = parser;\r\n    parser.Parser = Parser;\r\n    return new Parser;\r\n})();\r\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\r\n    exports.parser = xpathA;\r\n    exports.Parser = xpathA.Parser;\r\n    exports.parse = function () { return xpathA.parse.apply(xpathA, arguments); };\r\n    exports.main = function commonjsMain(args) {\r\n        if (!args[1]) {\r\n            console.log('Usage: ' + args[0] + ' FILE');\r\n            process.exit(1);\r\n        }\r\n        var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\r\n        return exports.parser.parse(source);\r\n    };\r\n    if (typeof module !== 'undefined' && require.main === module) {\r\n        exports.main(process.argv.slice(1));\r\n    }\r\n}\r\n","import { Component } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'app-root',\r\n  templateUrl: './app.component.html',\r\n  styleUrls: ['./app.component.css']\r\n})\r\nexport class AppComponent {\r\n  title = 'frontend';\r\n}\r\n","<router-outlet></router-outlet>","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Fila_1 = require(\"./Fila\");\r\nconst Tipos_1 = require(\"./Tipos\");\r\nconst Tabla_1 = require(\"./Tabla\");\r\nconst Graficas_1 = require(\"../Graficas/Graficas\");\r\nclass EtiquetaSimple {\r\n    constructor(nombreTag, listaAtributos, linea, columna, idSent) {\r\n        this.nombreTag = nombreTag;\r\n        this.padre = null;\r\n        this.listaAtributos = listaAtributos;\r\n        this.linea = linea;\r\n        this.columna = columna;\r\n        this.idSent = idSent;\r\n        this.listaAtributos.forEach(atributo => {\r\n            atributo.etiquetaContendora = this;\r\n        });\r\n    }\r\n    getName() {\r\n        return this.nombreTag;\r\n    }\r\n    getAmbito() {\r\n        let listaAmbito = [];\r\n        for (let etiqueta = this.padre; etiqueta != null; etiqueta = etiqueta.padre) {\r\n            listaAmbito.push(etiqueta.getName());\r\n        }\r\n        listaAmbito.push(\"GLOBAL\");\r\n        return listaAmbito;\r\n    }\r\n    imprimir() {\r\n        let texto = \"\";\r\n        texto += \"<\" + this.nombreTag;\r\n        this.listaAtributos.forEach(atributo => {\r\n            texto += \" \" + atributo.imprimir();\r\n        });\r\n        texto += \"/> \\n\";\r\n        return texto;\r\n    }\r\n    getAsTable() {\r\n        let tabla = new Tabla_1.Tabla();\r\n        tabla.addFila(new Fila_1.Fila(this.getName(), Tipos_1.Tipos.ETIQUETA_SIMPLE, this.getAmbito(), this.linea, this.columna, this.imprimir()));\r\n        this.listaAtributos.forEach(atributo => {\r\n            tabla.addFila(atributo.getAsRowTable());\r\n        });\r\n        return tabla;\r\n    }\r\n    getErroresSemanticos() {\r\n        let texto = \"\";\r\n        this.listaAtributos.forEach(atributo => {\r\n            let apariciones = 0;\r\n            for (let atr2 of this.listaAtributos) {\r\n                if (atributo.nombre == atr2.nombre) {\r\n                    apariciones += 1;\r\n                }\r\n                if (apariciones > 1) {\r\n                    texto += `Error(Linea: ${atributo.linea}, Columna: ${atributo.columna}): El atributo '${atributo.nombre}' se encuentra repetido.\\n`;\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n        return texto;\r\n    }\r\n    getCstDotA(idPadre) {\r\n        let texto = \"\";\r\n        texto += Graficas_1.Graficas.getElement(this.idSent, \"TAG_UNICO\", idPadre);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 1, \"AbreTagCierre\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 2, \"<\" + this.nombreTag, this.idSent + 1);\r\n        if (this.listaAtributos.length > 0) {\r\n            let cont = 3;\r\n            for (let atributo of this.listaAtributos) {\r\n                if (cont - 3 != this.listaAtributos.length - 1) {\r\n                    texto += Graficas_1.Graficas.getElement(this.idSent + cont, \"LISTA_ATRIBUTOS\", this.idSent + cont + 1);\r\n                    texto += atributo.getCstDotA(this.idSent + cont);\r\n                }\r\n                else {\r\n                    texto += Graficas_1.Graficas.getElement(this.idSent + cont, \"LISTA_ATRIBUTOS\", this.idSent);\r\n                    texto += atributo.getCstDotA(this.idSent + cont);\r\n                }\r\n                cont += 1;\r\n            }\r\n        }\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 3 + this.listaAtributos.length, \"CierreTagCierre\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 4 + this.listaAtributos.length, \"\\\\>\", this.idSent + 3 + this.listaAtributos.length);\r\n        return texto;\r\n    }\r\n    getCstDotD(idPadre) {\r\n        let texto = \"\";\r\n        texto += Graficas_1.Graficas.getElement(this.idSent, \"TAG_UNICO\", idPadre);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 1, \"AbreTagCierre\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 2, \"<\" + this.nombreTag, this.idSent + 1);\r\n        if (this.listaAtributos.length > 0) {\r\n            let cont = 3;\r\n            for (let atributo of this.listaAtributos) {\r\n                let cont = 3;\r\n                for (let atributo of this.listaAtributos) {\r\n                    if (cont === 3) {\r\n                        texto += Graficas_1.Graficas.getElement(this.idSent + cont, \"LISTA_ATRIBUTOS\", this.idSent + 1);\r\n                        texto += atributo.getCstDotA(this.idSent + cont);\r\n                    }\r\n                    else {\r\n                        texto += Graficas_1.Graficas.getElement(this.idSent + cont, \"LISTA_ATRIBUTOS\", this.idSent + cont - 1);\r\n                        texto += atributo.getCstDotA(this.idSent + cont);\r\n                    }\r\n                    cont += 1;\r\n                }\r\n            }\r\n        }\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 3 + this.listaAtributos.length, \"CierreTagCierre\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 4 + this.listaAtributos.length, \"\\\\>\", this.idSent + 3 + this.listaAtributos.length);\r\n        return texto;\r\n    }\r\n}\r\nexports.EtiquetaSimple = EtiquetaSimple;\r\n","import { Component, OnInit, ViewChild } from '@angular/core';\r\nimport { FormControl } from '@angular/forms';\r\nimport { Observable } from 'rxjs';\r\nimport { CompiladorService } from 'src/app/services/compilador.service'\r\nimport { saveAs } from 'file-saver'\r\nimport { DomSanitizer } from '@angular/platform-browser';\r\nimport * as vis from \"vis\";\r\n\r\n\r\nimport { Buffer } from 'buffer/';\r\n//importamos para el editor\r\nimport { filter, take } from 'rxjs/operators';\r\nimport {\r\n  MonacoEditorComponent,\r\n  MonacoEditorConstructionOptions,\r\n  MonacoEditorLoaderService,\r\n  MonacoStandaloneCodeEditor\r\n} from '@materia-ui/ngx-monaco-editor';\r\nimport { THIS_EXPR } from '@angular/compiler/src/output/output_ast';\r\nimport { interpolateCividis } from 'd3';\r\nvar incov = require('iconv-lite');\r\n@Component({\r\n  selector: 'app-editor',\r\n  templateUrl: './editor.component.html',\r\n  styleUrls: ['./editor.component.css']\r\n})\r\nexport class EditorComponent implements OnInit {\r\n  nombreArchivo = \"Choose file\"\r\n  archivo: any\r\n  reporteSelccionado: string = \"\"\r\n  ConsultaOP:string=\"\"\r\n  textoEditores: string[] = [\"\"]\r\n  ReporteGramatica: any\r\n  analisis:string=\"\"\r\n  XPATH: string[] = [\"\"]\r\n  indiceEditorActual = 0\r\n  console: string = \"\";\r\n  xpath: string = \"\";\r\n  astJson: any\r\n  Error: any;\r\n  tablaSimbolos: any\r\n  astBase64: any\r\n\r\n  @ViewChild(MonacoEditorComponent, { static: false })\r\n  monacoComponent: MonacoEditorComponent = new MonacoEditorComponent(this.monacoLoaderService);\r\n  editorOptions: MonacoEditorConstructionOptions = {\r\n    theme: 'myCustomTheme',\r\n    language: '',\r\n    roundedSelection: true,\r\n    autoIndent: \"full\"\r\n  };\r\n\r\n  consoleOptions: MonacoEditorConstructionOptions = {\r\n    theme: 'myCustomTheme',\r\n    language: 'XML',\r\n    roundedSelection: true,\r\n    autoIndent: \"full\",\r\n    readOnly: true\r\n  };\r\n  XpathOptions: MonacoEditorConstructionOptions = {\r\n    theme: 'myCustomTheme',\r\n    language: '',\r\n    roundedSelection: true,\r\n    autoIndent: \"full\",\r\n    readOnly: true\r\n  };\r\n  constructor(private sanitizer: DomSanitizer, private monacoLoaderService: MonacoEditorLoaderService,\r\n    private compiladorService: CompiladorService) {\r\n    this.monacoLoaderService.isMonacoLoaded$\r\n      .pipe(\r\n        filter(isLoaded => isLoaded),\r\n        take(1)\r\n      )\r\n      .subscribe(() => {\r\n        monaco.editor.defineTheme('myCustomTheme', {\r\n          base: 'vs-dark', // can also be vs or hc-black\r\n          inherit: true, // can also be false to completely replace the builtin rules\r\n          rules: [\r\n            {\r\n              token: 'comment',\r\n              foreground: 'ffa500',\r\n              fontStyle: 'italic underline'\r\n            },\r\n            { token: 'comment.js', foreground: '008800', fontStyle: 'bold' },\r\n            { token: 'comment.css', foreground: '0000ff' } // will inherit fontStyle from `comment` above\r\n          ],\r\n          colors: {}\r\n        });\r\n      });\r\n  }\r\n\r\n  editorInit(editor: MonacoStandaloneCodeEditor) {\r\n    editor.setSelection({\r\n      startLineNumber: 1,\r\n      startColumn: 1,\r\n      endColumn: 500,\r\n      endLineNumber: 3\r\n    });\r\n  }\r\n\r\n  ngOnInit(): void {\r\n  }\r\n  esLetra(carcer: any) {\r\n    let ascii = carcer.toUpperCase().charCodeAt(0);\r\n    return ascii > 64 && ascii < 91;\r\n  }\r\n  compilar() {\r\n    this.console = \"\"\r\n    //  console.log(this.XPATH[this.indiceEditorActual])\r\n    this.xpath = \"\"\r\n    this.astJson = []\r\n    let Cadena = this.textoEditores[this.indiceEditorActual];\r\n \r\n\r\n  this.analisis=\"A\"\r\n    \r\n    let Cadena1 = Cadena.split('&lt;').join('<');\r\n\r\n    let Cadena2 = Cadena1.split('&gt;').join('>');\r\n\r\n    let Cadena3 = Cadena2.split('&amp;').join('&');\r\n\r\n\r\n    let Cadena4 = Cadena3.split('&apos;').join('\\'');\r\n\r\n    let Cadena5 = Cadena4.split('&quot;').join('\\\"');\r\n\r\n\r\n    /*\r\n    let Cadena1 = Cadena.replace(\"&lt;\", \"<\")\r\n\r\n    let Cadena2 = Cadena1.replace(\"&gt;\", \">\")\r\n\r\n    let Cadena3 = Cadena2.replace(\"&amp;\", \"&\")\r\n\r\n\r\n    let Cadena4 = Cadena3.replace(\"&apos;\", \"\\'\")\r\n\r\n    let Cadena5 = Cadena4.replace(\"&quot;\", \"\\\"\")\r\n\r\n    let cadef=  Cadena5.replace(\"&quot;\", \"\\\"\")\r\n*/\r\n    console.log(\"-----\" + Cadena5)\r\n\r\n\r\n\r\n    this.tablaSimbolos = this.compiladorService.analizar(Cadena5, this.XPATH[this.indiceEditorActual]).simbolo\r\n\r\n    this.ReporteGramatica = this.compiladorService.analizar(Cadena5, this.XPATH[this.indiceEditorActual]).ReporteGramatica\r\n    console.log(\"Encoding:::::::::::::::::::\" + this.compiladorService.analizar(Cadena5, this.XPATH[this.indiceEditorActual]).Encoding)\r\n    let ascii = \"\\\"ASCII\\\"\"\r\n\r\n\r\n\r\n    if (this.compiladorService.analizar(Cadena5, this.XPATH[this.indiceEditorActual]).Encoding == \"\\\"ASCII\\\"\") {\r\n      let consulta = this.compiladorService.analizar(Cadena5, this.XPATH[this.indiceEditorActual]).consulta\r\n      console.log(\"adentro del ascii\")\r\n      this.console = incov.decode(consulta, \"utf-8\");\r\n\r\n    }\r\n    else if (this.compiladorService.analizar(this.textoEditores[this.indiceEditorActual], this.XPATH[this.indiceEditorActual]).Encoding == \"\\\"UTF-8\\\" \") {\r\n      let consulta = this.compiladorService.analizar(Cadena5, this.XPATH[this.indiceEditorActual]).consulta\r\n      console.log(\"adentro del utf-8\")\r\n      this.console = incov.decode(consulta, \"utf-8\");\r\n\r\n    } //\r\n\r\n    else if (this.compiladorService.analizar(this.textoEditores[this.indiceEditorActual], this.XPATH[this.indiceEditorActual]).Encoding == \"\\\"ISO-8859-1\\\" \") {\r\n\r\n      let consulta = this.compiladorService.analizar(Cadena5, this.XPATH[this.indiceEditorActual]).consulta\r\n      console.log(\"adentro del latin1\")\r\n      this.console = incov.decode(consulta, \"latin1\");\r\n\r\n\r\n    }\r\n    else {\r\n      //  this.console=buf.toString(\"utf8\")\r\n      //console.log(\"adentro del utf 8\") \r\n\r\n      //  console.log(\"adentro del utf 8\") \r\n      // this.console.l\r\n      let consulta = this.compiladorService.analizar(Cadena5, this.XPATH[this.indiceEditorActual]).consulta\r\n      console.log(\"sin coincidencias\")\r\n      this.console = incov.decode(consulta, \"utf-8\");\r\n\r\n    }\r\n    this.Error = (this.compiladorService.analizar(Cadena5, this.XPATH[this.indiceEditorActual]).Error)\r\n\r\n    this.prueba(this.compiladorService.analizar(Cadena, this.XPATH[this.indiceEditorActual]).cst);\r\n\r\n  }\r\n  compilarD() {\r\n    this.console = \"\"\r\n\r\n\r\n    //  console.log(this.XPATH[this.indiceEditorActual])\r\n    this.xpath = \"\"\r\n    this.astJson = []\r\n    let Cadena = this.textoEditores[this.indiceEditorActual];\r\n this.analisis=\"D\"\r\n\r\n\r\n    \r\n    let Cadena1 = Cadena.split('&lt;').join('<');\r\n\r\n    let Cadena2 = Cadena1.split('&gt;').join('>');\r\n\r\n    let Cadena3 = Cadena2.split('&amp;').join('&');\r\n\r\n\r\n    let Cadena4 = Cadena3.split('&apos;').join('\\'');\r\n\r\n    let Cadena5 = Cadena4.split('&quot;').join('\\\"');\r\n\r\n\r\n    /*\r\n    let Cadena1 = Cadena.replace(\"&lt;\", \"<\")\r\n\r\n    let Cadena2 = Cadena1.replace(\"&gt;\", \">\")\r\n\r\n    let Cadena3 = Cadena2.replace(\"&amp;\", \"&\")\r\n\r\n\r\n    let Cadena4 = Cadena3.replace(\"&apos;\", \"\\'\")\r\n\r\n    let Cadena5 = Cadena4.replace(\"&quot;\", \"\\\"\")\r\n\r\n    let cadef=  Cadena5.replace(\"&quot;\", \"\\\"\")\r\n*/\r\n    console.log(\"-----\" + Cadena5)\r\n\r\n\r\n\r\n    this.tablaSimbolos = this.compiladorService.analizarD(Cadena5, this.XPATH[this.indiceEditorActual]).simbolo\r\n\r\n    this.ReporteGramatica = this.compiladorService.analizarD(Cadena5, this.XPATH[this.indiceEditorActual]).ReporteGramatica\r\n   \r\n    this.Error = (this.compiladorService.analizarD(Cadena5, this.XPATH[this.indiceEditorActual]).Error)\r\n\r\n    this.prueba(this.compiladorService.analizarD(Cadena, this.XPATH[this.indiceEditorActual]).cst);\r\n\r\n  }\r\n  seleccionarArchivo(event: any) {\r\n    this.nombreArchivo = event.target.files[0].name\r\n    this.archivo = event.target.files[0]\r\n  }\r\n  prueba(grafo: string) {\r\n    //   console.log(\"grafo0000000\"+grafo)\r\n\r\n    const container = document.getElementById(\"app\");\r\n    // provide data in the DOT language\r\n    var DOTstring = grafo;\r\n    var parsedData = vis.network.convertDot(DOTstring);\r\n    var options = parsedData.options;\r\n    options[\"physics\"] = {\r\n      enabled: false\r\n    };\r\n\r\n    options[\"layout\"] = {\r\n      improvedLayout: true,\r\n      hierarchical: {\r\n        enabled: true,\r\n        levelSeparation: 150,\r\n        treeSpacing: 35,\r\n        blockShifting: true,\r\n        edgeMinimization: true,\r\n        parentCentralization: true,\r\n        direction: \"UD\",\r\n        sortMethod: \"directed\"\r\n      },\r\n      font: {\r\n        size: 15,\r\n        color: 'gray'\r\n      },\r\n      borderWidth: 2\r\n    };\r\n\r\n\r\n\r\n    var network = new vis.Network(container, parsedData, options);\r\n\r\n    network.on(\"stabilizationIterationsDone\", function () {\r\n      network.setOptions({ physics: false });\r\n    });\r\n\r\n\r\n\r\n  }\r\n\r\n  cargarArchivo() {\r\n    const reader = new FileReader();\r\n    reader.onload = (e) => {\r\n      const text = reader.result!.toString().trim();\r\n      this.textoEditores[this.indiceEditorActual] = text\r\n    }\r\n    reader.readAsText(this.archivo);\r\n  }\r\n\r\n  agregarTab() {\r\n    this.textoEditores.push(\"\")\r\n    this.indiceEditorActual = this.textoEditores.length - 1\r\n  }\r\n\r\n  eliminarEditor(i: number) {\r\n    if (i != 0) {\r\n      this.textoEditores.splice(i, 1)\r\n      this.indiceEditorActual = 0\r\n    } else {\r\n      this.textoEditores[0] = \"\"\r\n    }\r\n  }\r\n\r\n  guardar() {\r\n    var file = new File([this.textoEditores[this.indiceEditorActual]], \"Codigo.ty\", {\r\n      type: \"text/plain\",\r\n    });\r\n    saveAs(file)\r\n  }\r\n\r\n  selectReporte(opcion: string) {\r\n    this.reporteSelccionado = opcion\r\n\r\n  }\r\n\r\n  Consulta() {\r\n\r\n      if (this.analisis=\"A\"){\r\n        let Cadena = this.textoEditores[this.indiceEditorActual];\r\n \r\n\r\n\r\n    \r\n        let Cadena1 = Cadena.split('&lt;').join('<');\r\n    \r\n        let Cadena2 = Cadena1.split('&gt;').join('>');\r\n    \r\n        let Cadena3 = Cadena2.split('&amp;').join('&');\r\n    \r\n    \r\n        let Cadena4 = Cadena3.split('&apos;').join('\\'');\r\n    \r\n        let Cadena5 = Cadena4.split('&quot;').join('\\\"');\r\n     console.log(\"Encoding:::::::::::::::::::\" + this.compiladorService.analizarC(Cadena5, this.XPATH[this.indiceEditorActual]).Encoding)\r\n        let ascii = \"\\\"ASCII\\\"\"\r\n    \r\n    \r\n    \r\n        if (this.compiladorService.analizarC(Cadena5, this.XPATH[this.indiceEditorActual]).Encoding == \"\\\"ASCII\\\"\") {\r\n          let consulta = this.compiladorService.analizarC(Cadena5, this.XPATH[this.indiceEditorActual]).consulta\r\n          console.log(\"adentro del ascii\")\r\n          this.console = incov.decode(consulta, \"utf-8\");\r\n    \r\n        }\r\n        else if (this.compiladorService.analizarC(this.textoEditores[this.indiceEditorActual], this.XPATH[this.indiceEditorActual]).Encoding == \"\\\"UTF-8\\\" \") {\r\n          let consulta = this.compiladorService.analizarC(Cadena5, this.XPATH[this.indiceEditorActual]).consulta\r\n          console.log(\"adentro del utf-8\")\r\n          this.console = incov.decode(consulta, \"utf-8\");\r\n    \r\n        } //\r\n    \r\n        else if (this.compiladorService.analizarC(this.textoEditores[this.indiceEditorActual], this.XPATH[this.indiceEditorActual]).Encoding == \"\\\"ISO-8859-1\\\" \") {\r\n    \r\n          let consulta = this.compiladorService.analizarC(Cadena5, this.XPATH[this.indiceEditorActual]).consulta\r\n          console.log(\"adentro del latin1\")\r\n          this.console = incov.decode(consulta, \"latin1\");\r\n    \r\n    \r\n        }\r\n        else {\r\n          //  this.console=buf.toString(\"utf8\")\r\n          //console.log(\"adentro del utf 8\") \r\n    \r\n          //  console.log(\"adentro del utf 8\") \r\n          // this.console.l\r\n          let consulta = this.compiladorService.analizarC(Cadena5, this.XPATH[this.indiceEditorActual]).consulta\r\n          console.log(\"sin coincidencias\")\r\n          this.console = incov.decode(consulta, \"utf-8\");\r\n    \r\n        }\r\n      }\r\n      else  if (this.analisis=\"D\"){\r\n\r\n\r\n\r\n        let Cadena = this.textoEditores[this.indiceEditorActual];\r\n \r\n\r\n\r\n    \r\n        let Cadena1 = Cadena.split('&lt;').join('<');\r\n    \r\n        let Cadena2 = Cadena1.split('&gt;').join('>');\r\n    \r\n        let Cadena3 = Cadena2.split('&amp;').join('&');\r\n    \r\n    \r\n        let Cadena4 = Cadena3.split('&apos;').join('\\'');\r\n    \r\n        let Cadena5 = Cadena4.split('&quot;').join('\\\"');\r\n     console.log(\"Encoding:::::::::::::::::::\" + this.compiladorService.analizarDC(Cadena5, this.XPATH[this.indiceEditorActual]).Encoding)\r\n        let ascii = \"\\\"ASCII\\\"\"\r\n    \r\n    \r\n    \r\n        if (this.compiladorService.analizarDC(Cadena5, this.XPATH[this.indiceEditorActual]).Encoding == \"\\\"ASCII\\\"\") {\r\n          let consulta = this.compiladorService.analizarC(Cadena5, this.XPATH[this.indiceEditorActual]).consulta\r\n          console.log(\"adentro del ascii\")\r\n          this.console = incov.decode(consulta, \"utf-8\");\r\n    \r\n        }\r\n        else if (this.compiladorService.analizarDC(this.textoEditores[this.indiceEditorActual], this.XPATH[this.indiceEditorActual]).Encoding == \"\\\"UTF-8\\\" \") {\r\n          let consulta = this.compiladorService.analizarDC(Cadena5, this.XPATH[this.indiceEditorActual]).consulta\r\n          console.log(\"adentro del utf-8\")\r\n          this.console = incov.decode(consulta, \"utf-8\");\r\n    \r\n        } //\r\n    \r\n        else if (this.compiladorService.analizarDC(this.textoEditores[this.indiceEditorActual], this.XPATH[this.indiceEditorActual]).Encoding == \"\\\"ISO-8859-1\\\" \") {\r\n    \r\n          let consulta = this.compiladorService.analizarDC(Cadena5, this.XPATH[this.indiceEditorActual]).consulta\r\n          console.log(\"adentro del latin1\")\r\n          this.console = incov.decode(consulta, \"latin1\");\r\n    \r\n    \r\n        }\r\n        else {\r\n          //  this.console=buf.toString(\"utf8\")\r\n          //console.log(\"adentro del utf 8\") \r\n    \r\n          //  console.log(\"adentro del utf 8\") \r\n          // this.console.l\r\n          let consulta = this.compiladorService.analizarDC(Cadena5, this.XPATH[this.indiceEditorActual]).consulta\r\n          console.log(\"sin coincidencias\")\r\n          this.console = incov.decode(consulta, \"utf-8\");\r\n    \r\n        }\r\n\r\n\r\n\r\n\r\n\r\n      }\r\n\r\n  }\r\n\r\n  imprimir() {\r\n  }\r\n\r\n}\r\n","\r\n<nav class=\"navbar navbar-expand-lg navbar-dark \">\r\n    <button class=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarColor01\"\r\n        aria-controls=\"navbarColor01\" aria-expanded=\"false\" aria-label=\"Toggle navigation\">\r\n        <span class=\"navbar-toggler-icon\"></span>\r\n    </button>\r\n\r\n    <div class=\"navbar\" id=\"navbarColor01\">\r\n        <ul class=\"navbar-nav mr-auto\">\r\n           \r\n            <li class=\"nav-item\">\r\n                <button (click)=\"Consulta()\" class=\"btn btn-primary opcion\">CONSULTA</button>\r\n            </li>\r\n            <li class=\"nav-item\">\r\n                <button (click)=\"selectReporte('tablaSimbolos')\" type=\"button\" class=\"btn btn-primary opcion\">REPORTES</button>\r\n            </li>\r\n            <!-- <li class=\"nav-item\">\r\n                <button (click)=\"selectReporte('tablaErrores')\" type=\"button\" class=\"btn btn-primary opcion\">Tabla de Errores</button>\r\n            </li> -->\r\n        </ul>\r\n    </div>\r\n</nav>\r\n\r\n<div class=\"card-body\">\r\n    \r\n<div style=\"width: 850px; height: 400px; margin: auto;\" class=\"monacoCointeiner\">\r\n    <div class=\"card text-white tarjeta\">\r\n        XPATH\r\n                                 \r\n    <ngx-monaco-editor [options]=\"editorOptions\"\r\n    [(ngModel)]=\"XPATH[indiceEditorActual]\" (init)=\"editorInit($event)\" aria-readonly=\"true\">\r\n</ngx-monaco-editor>\r\n</div>\r\n</div>\r\n</div>\r\n<div class=\"container-fluid\">\r\n    <div class=\"row justify-content-center contenedor\">\r\n        <div class=\"col-md-12\">\r\n            <br>\r\n            <div class=\"row\">\r\n                <div class=\"col-md-6\">\r\n                   \r\n                    <div class=\"card text-white tarjeta\">\r\n                    \r\n                        <div class=\"card-header\">\r\n                            <p class=\"lab\">Editor</p>\r\n                            <div *ngFor=\"let texto of textoEditores; let i = index; \"  (click)=\"indiceEditorActual = i\" type=\"button\" class=\"btn btn-primary tab verde\">\r\n                                <div class=\"equis\">TAB_{{i}}</div>\r\n                                <div (click)=\"imprimir()\" type=\"button\" class=\"btn btn-primary equisa verde\" (click)=\"eliminarEditor(i)\">x</div>\r\n                            </div>\r\n                            <button (click)=\"agregarTab()\" type=\"button\" class=\"btn btn-primary mas verde\">+</button>\r\n                            <!-- Button trigger modal -->\r\n                            <button (click)=\"imprimir()\" type=\"button\" class=\"btn btn-primary op mas verde\" data-toggle=\"modal\" data-target=\"#exampleModal\">\r\n                                Cargar Archivo\r\n                            </button>\r\n                            <button (click)=\"guardar()\" type=\"button\" class=\"btn btn-primary op mas verde\">Guardar</button>\r\n                         \r\n                   \r\n                        </div>\r\n\r\n                    \r\n                        <div class=\"card-body\">\r\n                            <div style=\"width: auto; height: 450px;\" class=\"monacoCointeiner\">\r\n                                <ngx-monaco-editor [options]=\"editorOptions\"\r\n                                    [(ngModel)]=\"textoEditores[indiceEditorActual]\" (init)=\"editorInit($event)\"></ngx-monaco-editor>\r\n                            </div>\r\n\r\n                          \r\n                        </div>\r\n                        <br>\r\n                    </div>\r\n                </div>\r\n                <div class=\"col-md-6\">\r\n                    <div class=\"card text-white tarjeta\">\r\n                        <div class=\"card-header\">\r\n                            Consola\r\n                            <button (click)=\"compilar()\" type=\"button\" class=\"btn btn-primary mas verde\">Compilador Ascendente</button>\r\n                          \r\n                            <button (click)=\"console=''\" type=\"button\" class=\"btn btn-primary mas op verde\">Limpiar</button>\r\n                            <button (click)=\"compilarD()\" type=\"button\" class=\"btn btn-primary mas verde\">Compilador Descendente</button>\r\n                            \r\n                        </div>\r\n                       \r\n                        <div class=\"card-body\">\r\n                            <div style=\"width: auto; height: 458px;\" class=\"monacoCointeiner\">\r\n                                <ngx-monaco-editor [options]=\"consoleOptions\"\r\n                                    [(ngModel)]=\"console\" (init)=\"editorInit($event)\" aria-readonly=\"true\">\r\n                                </ngx-monaco-editor>\r\n                         \r\n                            </div>\r\n\r\n                        </div>\r\n                        <br>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <div id=\"app\"  style=\"width: auto; height: 1000px;\" >\r\n        <img [src]=\"astBase64\" class=\"zoom\">\r\n\r\n\r\n    </div>\r\n    <div *ngIf=\"reporteSelccionado === 'tablaSimbolos'\">\r\n\r\n        \r\n        <div class=\"row justify-content-center tabla\">\r\n            <div class=\"col-md-8 tab\">\r\n                <ul class=\"nav nav-tabs justify-content-center\">\r\n                    <li class=\"nav-item active\">\r\n                        <a class=\"nav-link active\" data-toggle=\"tab\" href=\"#simbolos\">Tabla de Smbolos</a>\r\n                    </li>\r\n                </ul>\r\n               \r\n                <div id=\"myTabContent\" class=\"tab-content\">\r\n                    <div class=\"tab-pane fade in active show\" id=\"simbolos\">\r\n                        <div class=\"col-md-12\">\r\n                            <br>\r\n                            <div style=\"width: auto; height: auto;\">\r\n                                <table class=\"table table-hover table-hover\">\r\n                                    <thead>\r\n                                        <tr>\r\n                                            <td>NOMBRE</td>\r\n                                            <td>TIPO_SIMBOLO</td>\r\n                                            <td>AMBITO</td>\r\n                                            <td>COLUMNA</td>\r\n                                            <td>FILA</td>\r\n                                            <td>VALOR</td>\r\n                                        </tr>\r\n                                    </thead>\r\n                                    <tbody>\r\n                                        <tr *ngFor=\"let fila of tablaSimbolos\">\r\n                                            <td>{{fila.nombre}}</td>\r\n                                            <td>{{fila.tipo}}</td>\r\n                                            <td>-{{fila.listaAmbito.join(\"-\")}}-</td>\r\n                                            <td>{{fila.columna}}</td>\r\n                                            <td>{{fila.fila}}</td>\r\n                                            <td>--{{fila.valor}}--</td>\r\n                                        </tr>\r\n                                    \r\n                                    </tbody>\r\n                                </table>\r\n                            </div>\r\n        \r\n                            <div style=\"width: auto; height: auto;\">\r\n                                <ul class=\"nav nav-tabs justify-content-center\">\r\n                                    <li class=\"nav-item active\">\r\n                                        <a class=\"nav-link active\" data-toggle=\"tab\" href=\"#simbolos\">ReporteGramaticaL</a>\r\n                                    </li>\r\n                                </ul>\r\n                                <table class=\"table table-hover table-hover\">\r\n                                    <thead>\r\n                                        <tr>\r\n                                            <td>PRODUCCION</td>\r\n                                            <td>regla_semantica</td>\r\n                                         \r\n                                        </tr>\r\n                                    </thead>\r\n                                    <tbody>\r\n                                        <tr *ngFor=\"let fila of ReporteGramatica\">\r\n                                            <td>{{fila.produccion}}</td>\r\n                                            <td>{{fila.regla_semantica}}</td>\r\n                                        </tr>\r\n                                    \r\n                                    </tbody>\r\n                                </table>\r\n                            </div>\r\n                            <br>\r\n                        </div>\r\n                    </div>\r\n                    <div style=\"width: auto; height: auto;\">\r\n                        <ul class=\"nav nav-tabs justify-content-center\">\r\n                            <li class=\"nav-item active\">\r\n                                <a class=\"nav-link active\" data-toggle=\"tab\" href=\"#simbolos\">ERRORES</a>\r\n                            </li>\r\n                        </ul>\r\n\r\n                     \r\n                        <table class=\"table table-hover table-hover\">\r\n                            <thead>\r\n                                <tr> \r\n                                    <td>SIMBOLO</td>\r\n                                    <td>TIPO</td>\r\n                                    <td>Linea</td>\r\n                                    <td>Columna</td>\r\n                                    <td>Entorno</td>\r\n                                    \r\n                                 \r\n                                </tr>\r\n                            </thead>\r\n                            <tbody>\r\n                                <tr *ngFor=\"let fila of Error\">\r\n                                    <td>{{fila.simbolo}}</td>\r\n                                    <td>{{fila.tipo}}</td>\r\n                                    <td>{{fila.linea}}</td>\r\n                                    <td>{{fila.columna}}</td>\r\n                                    <td>{{fila.entorno}}</td>\r\n                                </tr>\r\n                            \r\n                            </tbody>\r\n                        </table>\r\n                    </div>\r\n                    <div class=\"tab-pane fade\" id=\"errores\">\r\n                        <div class=\"col-md-12\">\r\n                            <br>\r\n                            <div style=\"width: auto; height: auto;\">\r\n                                <table class=\"table table-danger table-hover\">\r\n                                    <thead>\r\n                                        <tr>\r\n                                            <td>hola</td>\r\n                                            <td>mundo</td>\r\n                                        </tr>\r\n                                    </thead>\r\n                                    <tbody>\r\n                                        <tr>\r\n                                            <td>1</td>\r\n                                            <td>2</td>\r\n                                        </tr>\r\n                                    </tbody>\r\n                                </table>\r\n                            </div>\r\n                            <br>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n    </div>\r\n  \r\n    <div  id =\"app\" *ngIf=\"reporteSelccionado === 'arbolAst'\">\r\n        <img [src]=\"astBase64\" class=\"zoom\">\r\n        alv\r\n    </div>\r\n \r\n   \r\n</div>\r\n<script>\r\n  export  function prueba(){\r\n        console.log(this.astBase64)\r\n \r\n    }\r\n   \r\n\r\n\r\n</script>\r\n<!-- Modal -->\r\n<div class=\"modal fade\" id=\"exampleModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"exampleModalLabel\"\r\n        aria-hidden=\"true\">\r\n    <div class=\"modal-dialog\" role=\"document\">\r\n        <div class=\"modal-content\">\r\n            <div class=\"modal-header\">\r\n                <h5 class=\"modal-title\" id=\"exampleModalLabel\">Cargar archivo de entrada</h5>\r\n            </div>\r\n            <div class=\"modal-body\">\r\n                <div class=\"input-group\">\r\n                    <div class=\"custom-file\">\r\n                        <input type=\"file\" class=\"custom-file-input\" id=\"inputGroupFile01\"\r\n                                aria-describedby=\"inputGroupFileAddon01\" (change)=\"seleccionarArchivo($event)\">\r\n                        <label class=\"custom-file-label\" for=\"inputGroupFile01\" id=\"choosedFile\"\r\n                                accept=\".xml\">{{nombreArchivo}}</label>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            <div class=\"modal-footer\">\r\n                <button type=\"button\" class=\"btn btn-primary\" (click)=\"cargarArchivo()\" data-dismiss=\"modal\">Continuar</button>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n<!-- fin de boostrap -->\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TiposOp;\r\n(function (TiposOp) {\r\n    TiposOp[\"SUMA\"] = \"SUMA\";\r\n    TiposOp[\"RESTA\"] = \"RESTA\";\r\n    TiposOp[\"MULTIPLICACION\"] = \"MULTIPLICACION\";\r\n    TiposOp[\"DIVISION\"] = \"DIVISION\";\r\n    TiposOp[\"MODULO\"] = \"MODULO\";\r\n    TiposOp[\"AND\"] = \"AND\";\r\n    TiposOp[\"OR\"] = \"OR\";\r\n    TiposOp[\"ASIGNACION\"] = \"ASIGNACION\";\r\n    TiposOp[\"NO_IGUAL\"] = \"NO_IGUAL\";\r\n    TiposOp[\"MAYOR_QUE\"] = \"MAYOR_QUE\";\r\n    TiposOp[\"MENOR_QUE\"] = \"MENOR_QUE\";\r\n    TiposOp[\"MAYOR_IGUAL\"] = \"MAYOR_IGUAL\";\r\n    TiposOp[\"MENOR_IGUAL\"] = \"MENOR_IGUAL\";\r\n})(TiposOp = exports.TiposOp || (exports.TiposOp = {}));\r\n","/* parser generated by jison 0.4.18 */\r\n/*\r\n  Returns a Parser object of the following structure:\r\n\r\n  Parser: {\r\n    yy: {}\r\n  }\r\n\r\n  Parser.prototype: {\r\n    yy: {},\r\n    trace: function(),\r\n    symbols_: {associative list: name ==> number},\r\n    terminals_: {associative list: number ==> name},\r\n    productions_: [...],\r\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\r\n    table: [...],\r\n    defaultActions: {...},\r\n    parseError: function(str, hash),\r\n    parse: function(input),\r\n\r\n    lexer: {\r\n        EOF: 1,\r\n        parseError: function(str, hash),\r\n        setInput: function(input),\r\n        input: function(),\r\n        unput: function(str),\r\n        more: function(),\r\n        less: function(n),\r\n        pastInput: function(),\r\n        upcomingInput: function(),\r\n        showPosition: function(),\r\n        test_match: function(regex_match_array, rule_index),\r\n        next: function(),\r\n        lex: function(),\r\n        begin: function(condition),\r\n        popState: function(),\r\n        _currentRules: function(),\r\n        topState: function(),\r\n        pushState: function(condition),\r\n\r\n        options: {\r\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\r\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\r\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\r\n        },\r\n\r\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\r\n        rules: [...],\r\n        conditions: {associative list: name ==> set},\r\n    }\r\n  }\r\n\r\n\r\n  token location info (@$, _$, etc.): {\r\n    first_line: n,\r\n    last_line: n,\r\n    first_column: n,\r\n    last_column: n,\r\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\r\n  }\r\n\r\n\r\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\r\n    text:        (matched text)\r\n    token:       (the produced terminal token, if any)\r\n    line:        (yylineno)\r\n  }\r\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\r\n    loc:         (yylloc)\r\n    expected:    (string describing the set of expected tokens)\r\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\r\n  }\r\n*/\r\nvar xpathD = (function () {\r\n    var o = function (k, v, o, l) { for (o = o || {}, l = k.length; l--; o[k[l]] = v)\r\n        ; return o; }, $V0 = [1, 5], $V1 = [1, 8], $V2 = [1, 9], $V3 = [1, 6], $V4 = [2, 4], $V5 = [1, 12], $V6 = [5, 8], $V7 = [2, 5, 8, 11, 12, 13], $V8 = [13, 16, 19, 20, 21];\r\n    var parser = { trace: function trace() { },\r\n        yy: {},\r\n        symbols_: { \"error\": 2, \"XPATH\": 3, \"CONCATENACION_SETS\": 4, \"EOF\": 5, \"LISTA_SETS\": 6, \"CONCATENACION_SETSAUX\": 7, \"barraVertical\": 8, \"SET\": 9, \"SELECTOR\": 10, \"slash\": 11, \"dobleSlash\": 12, \"identificador\": 13, \"MENU_SELECTOR\": 14, \"MenuIdentificador\": 15, \"arroba\": 16, \"MenuArroba\": 17, \"MENU_SET\": 18, \"dosPuntos\": 19, \"punto\": 20, \"asterisco\": 21, \"PREDICADO\": 22, \"corecheteA\": 23, \"OPERACION\": 24, \"corcheteC\": 25, \"entero\": 26, \"decimal\": 27, \"MENU_OPERACION\": 28, \"mas\": 29, \"menos\": 30, \"$accept\": 0, \"$end\": 1 },\r\n        terminals_: { 2: \"error\", 5: \"EOF\", 8: \"barraVertical\", 11: \"slash\", 12: \"dobleSlash\", 13: \"identificador\", 16: \"arroba\", 19: \"dosPuntos\", 20: \"punto\", 21: \"asterisco\", 23: \"corecheteA\", 25: \"corcheteC\", 26: \"entero\", 27: \"decimal\", 29: \"mas\", 30: \"menos\" },\r\n        productions_: [0, [3, 2], [4, 2], [7, 3], [7, 0], [6, 2], [6, 1], [6, 1], [10, 1], [10, 1], [9, 1], [9, 2], [14, 2], [14, 2], [14, 1], [18, 1], [18, 1], [18, 1], [15, 1], [15, 0], [17, 1], [17, 1], [22, 3], [24, 1], [24, 1], [28, 2], [28, 2], [28, 2], [28, 2]],\r\n        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\r\n            /* this == yyval */\r\n            var $0 = $$.length - 1;\r\n            switch (yystate) {\r\n                case 1:\r\n                    return $$[$0 - 1];\r\n                    break;\r\n                case 2:\r\n                case 3:\r\n                    $$[$0].push($$[$0 - 1]);\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 4:\r\n                    this.$ = [];\r\n                    break;\r\n                case 5:\r\n                    aux = $$[$0];\r\n                    while (aux.next != null) {\r\n                        aux = aux.next;\r\n                    }\r\n                    ;\r\n                    aux.next = $$[$0 - 1];\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 6:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 7:\r\n                    this.$ = listaError.push(new ControlError(yytext, TipoSeleccion.ERROR_SINTACTICO, this._$.first_line, this._$.first_column, \"XpathDescendente\"));\r\n                    break;\r\n                case 8:\r\n                case 9:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 10:\r\n                    this.$ = { tipo: TipoSeleccion.ACCESO_NODO_RAIZ, id: $$[$0], next: null };\r\n                    break;\r\n                case 11:\r\n                    this.$ = { tipo: TipoSeleccion.SELECT_NODOS_FROM_NODO, selector: $$[$0 - 1], id: $$[$0].ids, predicado: $$[$0].predicados, next: null };\r\n                    break;\r\n                case 12:\r\n                    this.$ = {\r\n                        ids: $$[$0 - 1],\r\n                        predicados: $$[$0]\r\n                    };\r\n                    break;\r\n                case 18:\r\n                    this.$ = $$[$0];\r\n                    break;\r\n                case 19:\r\n                    this.$ = null;\r\n                    break;\r\n                case 22:\r\n                    this.$ = $$[$0 - 1];\r\n                    break;\r\n                case 23:\r\n                    this.$ = new Primitivo(parseInt($$[$0]), TipoVal.ENTERO);\r\n                    break;\r\n                case 24:\r\n                    this.$ = new Primitivo(parseFloat($$[$0]), TipoVal.DECIMAL);\r\n                    break;\r\n                case 25:\r\n                    this.$ =\r\n                        {\r\n                            tipo: TiposOp.SUMA,\r\n                            op: $$[$0]\r\n                        };\r\n                    break;\r\n                case 26:\r\n                    this.$ =\r\n                        {\r\n                            tipo: TiposOp.RESTA,\r\n                            op: $$[$0]\r\n                        };\r\n                    break;\r\n                case 27:\r\n                    this.$ =\r\n                        {\r\n                            tipo: TiposOp.MULTIPLICACION,\r\n                            op: $$[$0]\r\n                        };\r\n                    break;\r\n                case 28:\r\n                    this.$ =\r\n                        {\r\n                            tipo: TiposOp.DIVISION,\r\n                            op: $$[$0]\r\n                        };\r\n                    break;\r\n            }\r\n        },\r\n        table: [{ 2: $V0, 3: 1, 4: 2, 6: 3, 9: 4, 10: 7, 11: $V1, 12: $V2, 13: $V3 }, { 1: [3] }, { 5: [1, 10] }, { 5: $V4, 7: 11, 8: $V5 }, o($V6, [2, 6], { 9: 4, 10: 7, 6: 13, 2: $V0, 11: $V1, 12: $V2, 13: $V3 }), o($V6, [2, 7]), o($V7, [2, 10]), { 13: [1, 15], 14: 14, 16: [1, 16], 18: 17, 19: [1, 18], 20: [1, 19], 21: [1, 20] }, o($V8, [2, 8]), o($V8, [2, 9]), { 1: [2, 1] }, { 5: [2, 2] }, { 2: $V0, 6: 21, 9: 4, 10: 7, 11: $V1, 12: $V2, 13: $V3 }, o($V6, [2, 5]), o($V7, [2, 11]), o($V7, [2, 19], { 15: 22, 22: 23, 23: [1, 24] }), { 13: [1, 26], 17: 25, 21: [1, 27] }, o($V7, [2, 14]), o($V7, [2, 15]), o($V7, [2, 16]), o($V7, [2, 17]), { 5: $V4, 7: 28, 8: $V5 }, o($V7, [2, 12]), o($V7, [2, 18]), { 24: 29, 26: [1, 30], 27: [1, 31] }, o($V7, [2, 13]), o($V7, [2, 20]), o($V7, [2, 21]), { 5: [2, 3] }, { 25: [1, 32] }, { 25: [2, 23] }, { 25: [2, 24] }, o($V7, [2, 22])],\r\n        defaultActions: { 10: [2, 1], 11: [2, 2], 28: [2, 3], 30: [2, 23], 31: [2, 24] },\r\n        parseError: function parseError(str, hash) {\r\n            if (hash.recoverable) {\r\n                this.trace(str);\r\n            }\r\n            else {\r\n                var error = new Error(str);\r\n                error.hash = hash;\r\n                throw error;\r\n            }\r\n        },\r\n        parse: function parse(input) {\r\n            var self = this, stack = [0], tstack = [], // token stack\r\n            vstack = [null], // semantic value stack\r\n            lstack = [], // location stack\r\n            table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\r\n            var args = lstack.slice.call(arguments, 1);\r\n            //this.reductionCount = this.shiftCount = 0;\r\n            var lexer = Object.create(this.lexer);\r\n            var sharedState = { yy: {} };\r\n            // copy state\r\n            for (var k in this.yy) {\r\n                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\r\n                    sharedState.yy[k] = this.yy[k];\r\n                }\r\n            }\r\n            lexer.setInput(input, sharedState.yy);\r\n            sharedState.yy.lexer = lexer;\r\n            sharedState.yy.parser = this;\r\n            if (typeof lexer.yylloc == 'undefined') {\r\n                lexer.yylloc = {};\r\n            }\r\n            var yyloc = lexer.yylloc;\r\n            lstack.push(yyloc);\r\n            var ranges = lexer.options && lexer.options.ranges;\r\n            if (typeof sharedState.yy.parseError === 'function') {\r\n                this.parseError = sharedState.yy.parseError;\r\n            }\r\n            else {\r\n                this.parseError = Object.getPrototypeOf(this).parseError;\r\n            }\r\n            function popStack(n) {\r\n                stack.length = stack.length - 2 * n;\r\n                vstack.length = vstack.length - n;\r\n                lstack.length = lstack.length - n;\r\n            }\r\n            _token_stack: var lex = function () {\r\n                var token;\r\n                token = lexer.lex() || EOF;\r\n                // if token isn't its numeric value, convert\r\n                if (typeof token !== 'number') {\r\n                    token = self.symbols_[token] || token;\r\n                }\r\n                return token;\r\n            };\r\n            var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\r\n            while (true) {\r\n                // retreive state number from top of stack\r\n                state = stack[stack.length - 1];\r\n                // use default actions if available\r\n                if (this.defaultActions[state]) {\r\n                    action = this.defaultActions[state];\r\n                }\r\n                else {\r\n                    if (symbol === null || typeof symbol == 'undefined') {\r\n                        symbol = lex();\r\n                    }\r\n                    // read action for current state and first input\r\n                    action = table[state] && table[state][symbol];\r\n                }\r\n                _handle_error: \r\n                // handle parse error\r\n                if (typeof action === 'undefined' || !action.length || !action[0]) {\r\n                    var error_rule_depth;\r\n                    var errStr = '';\r\n                    // Return the rule stack depth where the nearest error rule can be found.\r\n                    // Return FALSE when no error recovery rule was found.\r\n                    function locateNearestErrorRecoveryRule(state) {\r\n                        var stack_probe = stack.length - 1;\r\n                        var depth = 0;\r\n                        // try to recover from error\r\n                        for (;;) {\r\n                            // check for error recovery rule in this state\r\n                            if ((TERROR.toString()) in table[state]) {\r\n                                return depth;\r\n                            }\r\n                            if (state === 0 || stack_probe < 2) {\r\n                                return false; // No suitable error recovery rule available.\r\n                            }\r\n                            stack_probe -= 2; // popStack(1): [symbol, action]\r\n                            state = stack[stack_probe];\r\n                            ++depth;\r\n                        }\r\n                    }\r\n                    if (!recovering) {\r\n                        // first see if there's any chance at hitting an error recovery rule:\r\n                        error_rule_depth = locateNearestErrorRecoveryRule(state);\r\n                        // Report error\r\n                        expected = [];\r\n                        for (p in table[state]) {\r\n                            if (this.terminals_[p] && p > TERROR) {\r\n                                expected.push(\"'\" + this.terminals_[p] + \"'\");\r\n                            }\r\n                        }\r\n                        if (lexer.showPosition) {\r\n                            errStr = 'Parse error on line ' + (yylineno + 1) + \":\\n\" + lexer.showPosition() + \"\\nExpecting \" + expected.join(', ') + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\r\n                        }\r\n                        else {\r\n                            errStr = 'Parse error on line ' + (yylineno + 1) + \": Unexpected \" +\r\n                                (symbol == EOF ? \"end of input\" :\r\n                                    (\"'\" + (this.terminals_[symbol] || symbol) + \"'\"));\r\n                        }\r\n                        this.parseError(errStr, {\r\n                            text: lexer.match,\r\n                            token: this.terminals_[symbol] || symbol,\r\n                            line: lexer.yylineno,\r\n                            loc: yyloc,\r\n                            expected: expected,\r\n                            recoverable: (error_rule_depth !== false)\r\n                        });\r\n                    }\r\n                    else if (preErrorSymbol !== EOF) {\r\n                        error_rule_depth = locateNearestErrorRecoveryRule(state);\r\n                    }\r\n                    // just recovered from another error\r\n                    if (recovering == 3) {\r\n                        if (symbol === EOF || preErrorSymbol === EOF) {\r\n                            throw new Error(errStr || 'Parsing halted while starting to recover from another error.');\r\n                        }\r\n                        // discard current lookahead and grab another\r\n                        yyleng = lexer.yyleng;\r\n                        yytext = lexer.yytext;\r\n                        yylineno = lexer.yylineno;\r\n                        yyloc = lexer.yylloc;\r\n                        symbol = lex();\r\n                    }\r\n                    // try to recover from error\r\n                    if (error_rule_depth === false) {\r\n                        throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');\r\n                    }\r\n                    popStack(error_rule_depth);\r\n                    preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token\r\n                    symbol = TERROR; // insert generic error symbol as new lookahead\r\n                    state = stack[stack.length - 1];\r\n                    action = table[state] && table[state][TERROR];\r\n                    recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\r\n                }\r\n                // this shouldn't happen, unless resolve defaults are off\r\n                if (action[0] instanceof Array && action.length > 1) {\r\n                    throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\r\n                }\r\n                switch (action[0]) {\r\n                    case 1: // shift\r\n                        //this.shiftCount++;\r\n                        stack.push(symbol);\r\n                        vstack.push(lexer.yytext);\r\n                        lstack.push(lexer.yylloc);\r\n                        stack.push(action[1]); // push state\r\n                        symbol = null;\r\n                        if (!preErrorSymbol) { // normal execution/no error\r\n                            yyleng = lexer.yyleng;\r\n                            yytext = lexer.yytext;\r\n                            yylineno = lexer.yylineno;\r\n                            yyloc = lexer.yylloc;\r\n                            if (recovering > 0) {\r\n                                recovering--;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // error just occurred, resume old lookahead f/ before error\r\n                            symbol = preErrorSymbol;\r\n                            preErrorSymbol = null;\r\n                        }\r\n                        break;\r\n                    case 2:\r\n                        // reduce\r\n                        //this.reductionCount++;\r\n                        len = this.productions_[action[1]][1];\r\n                        // perform semantic action\r\n                        yyval.$ = vstack[vstack.length - len]; // default to $$ = $1\r\n                        // default location, uses first token for firsts, last for lasts\r\n                        yyval._$ = {\r\n                            first_line: lstack[lstack.length - (len || 1)].first_line,\r\n                            last_line: lstack[lstack.length - 1].last_line,\r\n                            first_column: lstack[lstack.length - (len || 1)].first_column,\r\n                            last_column: lstack[lstack.length - 1].last_column\r\n                        };\r\n                        if (ranges) {\r\n                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\r\n                        }\r\n                        r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));\r\n                        if (typeof r !== 'undefined') {\r\n                            return r;\r\n                        }\r\n                        // pop off stack\r\n                        if (len) {\r\n                            stack = stack.slice(0, -1 * len * 2);\r\n                            vstack = vstack.slice(0, -1 * len);\r\n                            lstack = lstack.slice(0, -1 * len);\r\n                        }\r\n                        stack.push(this.productions_[action[1]][0]); // push nonterminal (reduce)\r\n                        vstack.push(yyval.$);\r\n                        lstack.push(yyval._$);\r\n                        // goto new state = table[STATE][NONTERMINAL]\r\n                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\r\n                        stack.push(newState);\r\n                        break;\r\n                    case 3:\r\n                        // accept\r\n                        return true;\r\n                }\r\n            }\r\n            return true;\r\n        } };\r\n    const { TipoSeleccion } = require('../Xpath/TipoSeleccion');\r\n    const { OpBinaria } = require('../Xpath/OpBinaria');\r\n    const { TiposOp } = require('../Xpath/TiposOp');\r\n    const { Primitivo } = require('../Xpath/Primitivo');\r\n    const { TipoVal } = require('../Xpath/TipoVal');\r\n    const { ControlError } = require('../Xpath/ControlError');\r\n    listaError = [];\r\n    /* generated by jison-lex 0.3.4 */\r\n    var lexer = (function () {\r\n        var lexer = ({\r\n            EOF: 1,\r\n            parseError: function parseError(str, hash) {\r\n                if (this.yy.parser) {\r\n                    this.yy.parser.parseError(str, hash);\r\n                }\r\n                else {\r\n                    throw new Error(str);\r\n                }\r\n            },\r\n            // resets the lexer, sets new input\r\n            setInput: function (input, yy) {\r\n                this.yy = yy || this.yy || {};\r\n                this._input = input;\r\n                this._more = this._backtrack = this.done = false;\r\n                this.yylineno = this.yyleng = 0;\r\n                this.yytext = this.matched = this.match = '';\r\n                this.conditionStack = ['INITIAL'];\r\n                this.yylloc = {\r\n                    first_line: 1,\r\n                    first_column: 0,\r\n                    last_line: 1,\r\n                    last_column: 0\r\n                };\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [0, 0];\r\n                }\r\n                this.offset = 0;\r\n                return this;\r\n            },\r\n            // consumes and returns one char from the input\r\n            input: function () {\r\n                var ch = this._input[0];\r\n                this.yytext += ch;\r\n                this.yyleng++;\r\n                this.offset++;\r\n                this.match += ch;\r\n                this.matched += ch;\r\n                var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\r\n                if (lines) {\r\n                    this.yylineno++;\r\n                    this.yylloc.last_line++;\r\n                }\r\n                else {\r\n                    this.yylloc.last_column++;\r\n                }\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range[1]++;\r\n                }\r\n                this._input = this._input.slice(1);\r\n                return ch;\r\n            },\r\n            // unshifts one char (or a string) into the input\r\n            unput: function (ch) {\r\n                var len = ch.length;\r\n                var lines = ch.split(/(?:\\r\\n?|\\n)/g);\r\n                this._input = ch + this._input;\r\n                this.yytext = this.yytext.substr(0, this.yytext.length - len);\r\n                //this.yyleng -= len;\r\n                this.offset -= len;\r\n                var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\r\n                this.match = this.match.substr(0, this.match.length - 1);\r\n                this.matched = this.matched.substr(0, this.matched.length - 1);\r\n                if (lines.length - 1) {\r\n                    this.yylineno -= lines.length - 1;\r\n                }\r\n                var r = this.yylloc.range;\r\n                this.yylloc = {\r\n                    first_line: this.yylloc.first_line,\r\n                    last_line: this.yylineno + 1,\r\n                    first_column: this.yylloc.first_column,\r\n                    last_column: lines ?\r\n                        (lines.length === oldLines.length ? this.yylloc.first_column : 0)\r\n                            + oldLines[oldLines.length - lines.length].length - lines[0].length :\r\n                        this.yylloc.first_column - len\r\n                };\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];\r\n                }\r\n                this.yyleng = this.yytext.length;\r\n                return this;\r\n            },\r\n            // When called from action, caches matched text and appends it on next action\r\n            more: function () {\r\n                this._more = true;\r\n                return this;\r\n            },\r\n            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\r\n            reject: function () {\r\n                if (this.options.backtrack_lexer) {\r\n                    this._backtrack = true;\r\n                }\r\n                else {\r\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\r\n                        text: \"\",\r\n                        token: null,\r\n                        line: this.yylineno\r\n                    });\r\n                }\r\n                return this;\r\n            },\r\n            // retain first n characters of the match\r\n            less: function (n) {\r\n                this.unput(this.match.slice(n));\r\n            },\r\n            // displays already matched input, i.e. for error messages\r\n            pastInput: function () {\r\n                var past = this.matched.substr(0, this.matched.length - this.match.length);\r\n                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\\n/g, \"\");\r\n            },\r\n            // displays upcoming input, i.e. for error messages\r\n            upcomingInput: function () {\r\n                var next = this.match;\r\n                if (next.length < 20) {\r\n                    next += this._input.substr(0, 20 - next.length);\r\n                }\r\n                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\r\n            },\r\n            // displays the character position where the lexing error occurred, i.e. for error messages\r\n            showPosition: function () {\r\n                var pre = this.pastInput();\r\n                var c = new Array(pre.length + 1).join(\"-\");\r\n                return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\r\n            },\r\n            // test the lexed token: return FALSE when not a match, otherwise return token\r\n            test_match: function (match, indexed_rule) {\r\n                var token, lines, backup;\r\n                if (this.options.backtrack_lexer) {\r\n                    // save context\r\n                    backup = {\r\n                        yylineno: this.yylineno,\r\n                        yylloc: {\r\n                            first_line: this.yylloc.first_line,\r\n                            last_line: this.last_line,\r\n                            first_column: this.yylloc.first_column,\r\n                            last_column: this.yylloc.last_column\r\n                        },\r\n                        yytext: this.yytext,\r\n                        match: this.match,\r\n                        matches: this.matches,\r\n                        matched: this.matched,\r\n                        yyleng: this.yyleng,\r\n                        offset: this.offset,\r\n                        _more: this._more,\r\n                        _input: this._input,\r\n                        yy: this.yy,\r\n                        conditionStack: this.conditionStack.slice(0),\r\n                        done: this.done\r\n                    };\r\n                    if (this.options.ranges) {\r\n                        backup.yylloc.range = this.yylloc.range.slice(0);\r\n                    }\r\n                }\r\n                lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\r\n                if (lines) {\r\n                    this.yylineno += lines.length;\r\n                }\r\n                this.yylloc = {\r\n                    first_line: this.yylloc.last_line,\r\n                    last_line: this.yylineno + 1,\r\n                    first_column: this.yylloc.last_column,\r\n                    last_column: lines ?\r\n                        lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\r\n                        this.yylloc.last_column + match[0].length\r\n                };\r\n                this.yytext += match[0];\r\n                this.match += match[0];\r\n                this.matches = match;\r\n                this.yyleng = this.yytext.length;\r\n                if (this.options.ranges) {\r\n                    this.yylloc.range = [this.offset, this.offset += this.yyleng];\r\n                }\r\n                this._more = false;\r\n                this._backtrack = false;\r\n                this._input = this._input.slice(match[0].length);\r\n                this.matched += match[0];\r\n                token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\r\n                if (this.done && this._input) {\r\n                    this.done = false;\r\n                }\r\n                if (token) {\r\n                    return token;\r\n                }\r\n                else if (this._backtrack) {\r\n                    // recover context\r\n                    for (var k in backup) {\r\n                        this[k] = backup[k];\r\n                    }\r\n                    return false; // rule action called reject() implying the next rule should be tested instead.\r\n                }\r\n                return false;\r\n            },\r\n            // return next match in input\r\n            next: function () {\r\n                if (this.done) {\r\n                    return this.EOF;\r\n                }\r\n                if (!this._input) {\r\n                    this.done = true;\r\n                }\r\n                var token, match, tempMatch, index;\r\n                if (!this._more) {\r\n                    this.yytext = '';\r\n                    this.match = '';\r\n                }\r\n                var rules = this._currentRules();\r\n                for (var i = 0; i < rules.length; i++) {\r\n                    tempMatch = this._input.match(this.rules[rules[i]]);\r\n                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\r\n                        match = tempMatch;\r\n                        index = i;\r\n                        if (this.options.backtrack_lexer) {\r\n                            token = this.test_match(tempMatch, rules[i]);\r\n                            if (token !== false) {\r\n                                return token;\r\n                            }\r\n                            else if (this._backtrack) {\r\n                                match = false;\r\n                                continue; // rule action called reject() implying a rule MISmatch.\r\n                            }\r\n                            else {\r\n                                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n                                return false;\r\n                            }\r\n                        }\r\n                        else if (!this.options.flex) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (match) {\r\n                    token = this.test_match(match, rules[index]);\r\n                    if (token !== false) {\r\n                        return token;\r\n                    }\r\n                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\r\n                    return false;\r\n                }\r\n                if (this._input === \"\") {\r\n                    return this.EOF;\r\n                }\r\n                else {\r\n                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\r\n                        text: \"\",\r\n                        token: null,\r\n                        line: this.yylineno\r\n                    });\r\n                }\r\n            },\r\n            // return next match that has a token\r\n            lex: function lex() {\r\n                var r = this.next();\r\n                if (r) {\r\n                    return r;\r\n                }\r\n                else {\r\n                    return this.lex();\r\n                }\r\n            },\r\n            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\r\n            begin: function begin(condition) {\r\n                this.conditionStack.push(condition);\r\n            },\r\n            // pop the previously active lexer condition state off the condition stack\r\n            popState: function popState() {\r\n                var n = this.conditionStack.length - 1;\r\n                if (n > 0) {\r\n                    return this.conditionStack.pop();\r\n                }\r\n                else {\r\n                    return this.conditionStack[0];\r\n                }\r\n            },\r\n            // produce the lexer rule set which is active for the currently active lexer condition state\r\n            _currentRules: function _currentRules() {\r\n                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\r\n                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\r\n                }\r\n                else {\r\n                    return this.conditions[\"INITIAL\"].rules;\r\n                }\r\n            },\r\n            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\r\n            topState: function topState(n) {\r\n                n = this.conditionStack.length - 1 - Math.abs(n || 0);\r\n                if (n >= 0) {\r\n                    return this.conditionStack[n];\r\n                }\r\n                else {\r\n                    return \"INITIAL\";\r\n                }\r\n            },\r\n            // alias for begin(condition)\r\n            pushState: function pushState(condition) {\r\n                this.begin(condition);\r\n            },\r\n            // return the number of states currently on the stack\r\n            stateStackSize: function stateStackSize() {\r\n                return this.conditionStack.length;\r\n            },\r\n            options: { \"case-insensitive\": true },\r\n            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\r\n                var YYSTATE = YY_START;\r\n                switch ($avoiding_name_collisions) {\r\n                    case 0:\r\n                        break;\r\n                    case 1:\r\n                        return 'menor';\r\n                        break;\r\n                    case 2:\r\n                        return 'mayor';\r\n                        break;\r\n                    case 3:\r\n                        return 12;\r\n                        break;\r\n                    case 4:\r\n                        return 11;\r\n                        break;\r\n                    case 5:\r\n                        return 'igual';\r\n                        break;\r\n                    case 6:\r\n                        return 8;\r\n                        break;\r\n                    case 7:\r\n                        return 29;\r\n                        break;\r\n                    case 8:\r\n                        return 30;\r\n                        break;\r\n                    case 9:\r\n                        return 21;\r\n                        break;\r\n                    case 10:\r\n                        return 'div';\r\n                        break;\r\n                    case 11:\r\n                        return 'noIgual';\r\n                        break;\r\n                    case 12:\r\n                        return 'mayorQue';\r\n                        break;\r\n                    case 13:\r\n                        return 'menorQue';\r\n                        break;\r\n                    case 14:\r\n                        return 'and';\r\n                        break;\r\n                    case 15:\r\n                        return 'or';\r\n                        break;\r\n                    case 16:\r\n                        return '@';\r\n                        break;\r\n                    case 17:\r\n                        return 20;\r\n                        break;\r\n                    case 18:\r\n                        return 19;\r\n                        break;\r\n                    case 19:\r\n                        return 'dobleDosPuntos';\r\n                        break;\r\n                    case 20:\r\n                        return 23;\r\n                        break;\r\n                    case 21:\r\n                        return 25;\r\n                        break;\r\n                    case 22:\r\n                        return 'parentesisA';\r\n                        break;\r\n                    case 23:\r\n                        return 'parentesisC';\r\n                        break;\r\n                    case 24:\r\n                        return 'ancestor';\r\n                        break;\r\n                    case 25:\r\n                        return 'ancestor-or-self';\r\n                        break;\r\n                    case 26:\r\n                        return 'attribute';\r\n                        break;\r\n                    case 27:\r\n                        return 'child';\r\n                        break;\r\n                    case 28:\r\n                        return 'descendant';\r\n                        break;\r\n                    case 29:\r\n                        return 'descendant-or-self';\r\n                        break;\r\n                    case 30:\r\n                        return 'following';\r\n                        break;\r\n                    case 31:\r\n                        return 'following-sibling';\r\n                        break;\r\n                    case 32:\r\n                        return \"namespace\";\r\n                        break;\r\n                    case 33:\r\n                        return 'parent';\r\n                        break;\r\n                    case 34:\r\n                        return 'preceding';\r\n                        break;\r\n                    case 35:\r\n                        return 'preceding-sibling';\r\n                        break;\r\n                    case 36:\r\n                        return 'self';\r\n                        break;\r\n                    case 37:\r\n                        return 'NODO';\r\n                        break;\r\n                    case 38:\r\n                        return 'LANG';\r\n                        break;\r\n                    case 39:\r\n                        return 'POSICION';\r\n                        break;\r\n                    case 40:\r\n                        return 'ULTIMO';\r\n                        break;\r\n                    case 41:\r\n                        return 'TEXTO';\r\n                        break;\r\n                    case 42:\r\n                        return 'CADENA';\r\n                        break;\r\n                    case 43:\r\n                        return 27;\r\n                        break;\r\n                    case 44:\r\n                        return 26;\r\n                        break;\r\n                    case 45:\r\n                        return 13;\r\n                        break;\r\n                    case 46:\r\n                        return 5;\r\n                        break;\r\n                    case 47:\r\n                        new ControlError(yy_.yytext, TipoSeleccion.ERROR_LEXICO, yy_.yylloc.first_line, yy_.yylloc.first_column, \"XpathDescendente\");\r\n                        break;\r\n                }\r\n            },\r\n            rules: [/^(?:[\\s]+)/i, /^(?:<)/i, /^(?:>)/i, /^(?:\\/\\/)/i, /^(?:\\/)/i, /^(?:=)/i, /^(?:\\|)/i, /^(?:\\+)/i, /^(?:-)/i, /^(?:\\*)/i, /^(?:div\\b)/i, /^(?:!=)/i, /^(?:>=)/i, /^(?:<=)/i, /^(?:and\\b)/i, /^(?:or\\b)/i, /^(?:@)/i, /^(?:\\.)/i, /^(?:\\.\\.)/i, /^(?:::)/i, /^(?:\\[)/i, /^(?:\\])/i, /^(?:\\()/i, /^(?:\\))/i, /^(?:ancestor\\b)/i, /^(?:ancestor-or-self\\b)/i, /^(?:attribute\\b)/i, /^(?:child\\b)/i, /^(?:descendant\\b)/i, /^(?:descendant-or-self\\b)/i, /^(?:following\\b)/i, /^(?:following-sibling\\b)/i, /^(?:namespace\\b)/i, /^(?:parent\\b)/i, /^(?:preceding\\b)/i, /^(?:preceding-sibling\\b)/i, /^(?:self\\b)/i, /^(?:node\\b)/i, /^(?:lang\\b)/i, /^(?:position\\b)/i, /^(?:last\\b)/i, /^(?:text\\b)/i, /^(?:'[^\\']*')/i, /^(?:[0-9]+(\\.[0-9]+)\\b)/i, /^(?:[0-9]+\\b)/i, /^(?:[a-zA-Z_][a-zA-Z0-9_]*)/i, /^(?:$)/i, /^(?:.)/i],\r\n            conditions: { \"INITIAL\": { \"rules\": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47], \"inclusive\": true } }\r\n        });\r\n        return lexer;\r\n    })();\r\n    parser.lexer = lexer;\r\n    function Parser() {\r\n        this.yy = {};\r\n    }\r\n    Parser.prototype = parser;\r\n    parser.Parser = Parser;\r\n    return new Parser;\r\n})();\r\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\r\n    exports.parser = xpathD;\r\n    exports.Parser = xpathD.Parser;\r\n    exports.parse = function () { return xpathD.parse.apply(xpathD, arguments); };\r\n    exports.main = function commonjsMain(args) {\r\n        if (!args[1]) {\r\n            console.log('Usage: ' + args[0] + ' FILE');\r\n            process.exit(1);\r\n        }\r\n        var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\r\n        return exports.parser.parse(source);\r\n    };\r\n    if (typeof module !== 'undefined' && require.main === module) {\r\n        exports.main(process.argv.slice(1));\r\n    }\r\n}\r\n","import { BrowserModule } from '@angular/platform-browser';\r\nimport { NgModule } from '@angular/core';\r\nimport { ReactiveFormsModule, FormsModule } from '@angular/forms';\r\nimport { HttpClientModule } from \"@angular/common/http\";\r\n\r\nimport { AppRoutingModule } from './app-routing.module';\r\nimport { AppComponent } from './app.component';\r\nimport { EditorComponent } from './components/editor/editor.component';\r\nimport { MonacoEditorModule, MONACO_PATH } from '@materia-ui/ngx-monaco-editor';\r\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\r\nimport { ArbolAstComponent } from 'src/app/components/arbol-ast/arbol-ast.component';\nimport { TablaSimbolosComponent } from './components/tabla-simbolos/tabla-simbolos.component'\r\n\r\n@NgModule({\r\n  declarations: [\r\n    AppComponent,\r\n    EditorComponent,\r\n    ArbolAstComponent,\r\n    TablaSimbolosComponent,\r\n  ],\r\n  imports: [\r\n    BrowserModule,\r\n    AppRoutingModule,\r\n    ReactiveFormsModule,\r\n    FormsModule,\r\n    MonacoEditorModule,\r\n    BrowserAnimationsModule,\r\n    HttpClientModule\r\n  ],\r\n  providers: [\r\n    {\r\n      provide: MONACO_PATH,\r\n      useValue: 'https://unpkg.com/monaco-editor@0.19.3/min/vs'\r\n    }\r\n  ],\r\n  bootstrap: [AppComponent]\r\n})\r\nexport class AppModule { }\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar TipoVal;\r\n(function (TipoVal) {\r\n    TipoVal[\"ENTERO\"] = \"ENTERO\";\r\n    TipoVal[\"ID\"] = \"ID\";\r\n    TipoVal[\"DECIMAL\"] = \"DECIMAL\";\r\n    TipoVal[\"CADENA\"] = \"CADENA\";\r\n    TipoVal[\"ARROBA\"] = \"ARROBA\";\r\n    TipoVal[\"PUNTO\"] = \"PUTNO\";\r\n    TipoVal[\"LANG\"] = \"LANG\";\r\n    TipoVal[\"TEXTO\"] = \"TEXTO\";\r\n    TipoVal[\"POSICION\"] = \"POSICION\";\r\n    TipoVal[\"NODO\"] = \"NODO\";\r\n    TipoVal[\"BOLEANO\"] = \"BOLEANO\";\r\n    TipoVal[\"LAST\"] = \"LAST\";\r\n})(TipoVal = exports.TipoVal || (exports.TipoVal = {}));\r\n","<div class=\"row justify-content-center tabla\">\r\n    <div class=\"col-md-8 tab\">\r\n        <ul class=\"nav nav-tabs justify-content-center\">\r\n            <li class=\"nav-item active\">\r\n                <a class=\"nav-link active\" data-toggle=\"tab\" href=\"#simbolos\">Tabla de Smbolos</a>\r\n            </li>\r\n        </ul>\r\n       \r\n        <div id=\"myTabContent\" class=\"tab-content\">\r\n            <div class=\"tab-pane fade in active show\" id=\"simbolos\">\r\n                <div class=\"col-md-12\">\r\n                    <br>\r\n                    <div style=\"width: auto; height: auto;\">\r\n                        <table class=\"table table-hover table-hover\">\r\n                            <thead>\r\n                                <tr>\r\n                                    <td>NOMBRE</td>\r\n                                    <td>TIPO_SIMBOLO</td>\r\n                                    <td>AMBITO</td>\r\n                                    <td>COLUMNA</td>\r\n                                    <td>FILA</td>\r\n                                    <td>VALOR</td>\r\n                                </tr>\r\n                            </thead>\r\n                            <tbody>\r\n                                <tr *ngFor=\"let fila of tablaSimbolos\">\r\n                                    <td>{{fila.nombre}}</td>\r\n                                    <td>{{fila.tipo}}</td>\r\n                                    <td>-{{fila.listaAmbito.join(\"-\")}}-</td>\r\n                                    <td>{{fila.columna}}</td>\r\n                                    <td>{{fila.fila}}</td>\r\n                                    <td>--{{fila.valor}}--</td>\r\n                                </tr>\r\n                            \r\n                            </tbody>\r\n                        </table>\r\n                    </div>\r\n\r\n                    <div style=\"width: auto; height: auto;\">\r\n                        <ul class=\"nav nav-tabs justify-content-center\">\r\n                            <li class=\"nav-item active\">\r\n                                <a class=\"nav-link active\" data-toggle=\"tab\" href=\"#simbolos\">Tabla de Smbolos</a>\r\n                            </li>\r\n                        </ul>\r\n                        <table class=\"table table-primary table-hover\">\r\n                            <thead>\r\n                                <tr>\r\n                                    <td>PRODUCCION</td>\r\n                                    <td>regla_semantica</td>\r\n                                 \r\n                                </tr>\r\n                            </thead>\r\n                            <tbody>\r\n                                <tr *ngFor=\"let fila of ReporteGramatica\">\r\n                                    <td>{{fila.produccion}}</td>\r\n                                    <td>{{fila.regla_semantica}}</td>\r\n                                </tr>\r\n                            \r\n                            </tbody>\r\n                        </table>\r\n                    </div>\r\n                    <br>\r\n                </div>\r\n            </div>\r\n            <div class=\"tab-pane fade\" id=\"errores\">\r\n                <div class=\"col-md-12\">\r\n                    <br>\r\n                    <div style=\"width: auto; height: auto;\">\r\n                        <table class=\"table table-danger table-hover\">\r\n                            <thead>\r\n                                <tr>\r\n                                    <td>hola</td>\r\n                                    <td>mundo</td>\r\n                                </tr>\r\n                            </thead>\r\n                            <tbody>\r\n                                <tr>\r\n                                    <td>1</td>\r\n                                    <td>2</td>\r\n                                </tr>\r\n                            </tbody>\r\n                        </table>\r\n                    </div>\r\n                    <br>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>","import { Component, Input, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-tabla-simbolos',\n  templateUrl: './tabla-simbolos.component.html',\n  styleUrls: ['./tabla-simbolos.component.css']\n})\nexport class TablaSimbolosComponent implements OnInit {\n\n  @Input() tablaSimbolos:any \n            error:any\n            ReporteGramatica:any\n\n  constructor() {\n\n\n      }\n\n  ngOnInit(): void {\n  }\n\n}\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass Fila {\r\n    constructor(nombre, tipo, listaAmbito, fila, columna, valor) {\r\n        this.nombre = nombre;\r\n        this.tipo = tipo;\r\n        this.listaAmbito = listaAmbito;\r\n        this.fila = fila;\r\n        this.columna = columna;\r\n        this.valor = valor;\r\n    }\r\n}\r\nexports.Fila = Fila;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst NodoReporteGramatica_1 = require(\"./NodoReporteGramatica\");\r\nclass ReporteGramatica {\r\n    constructor(produccion, regla_semantica) {\r\n        ReporteGramatica.Lista.push(new NodoReporteGramatica_1.NodoReporteGramatica(produccion, regla_semantica));\r\n    }\r\n}\r\nexports.ReporteGramatica = ReporteGramatica;\r\nReporteGramatica.Lista = [];\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Graficas;\r\n(function (Graficas) {\r\n    function formatId(numId) {\r\n        return \"nodo\" + numId.toString();\r\n    }\r\n    function defNodo(nodoId, etiqueta) {\r\n        return formatId(nodoId) + \"[label=\\\"\" + etiqueta + \"\\\"] \\n\";\r\n    }\r\n    Graficas.defNodo = defNodo;\r\n    function defEdge(id1, id2) {\r\n        return formatId(id1) + \" -> \" + formatId(id2) + \"\\n\";\r\n    }\r\n    Graficas.defEdge = defEdge;\r\n    function getElement(id, etiqueta, idPadre) {\r\n        let dotText = \"\";\r\n        dotText += defNodo(id, etiqueta);\r\n        dotText += defEdge(idPadre, id);\r\n        return dotText;\r\n    }\r\n    Graficas.getElement = getElement;\r\n})(Graficas = exports.Graficas || (exports.Graficas = {}));\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Graficas_1 = require(\"../Graficas/Graficas\");\r\nclass EtiquetaInicio {\r\n    constructor(listaAtributos, linea, columna, idSent) {\r\n        this.linea = linea;\r\n        this.columna = columna;\r\n        this.idSent = idSent;\r\n        listaAtributos.forEach(atributo => {\r\n            if (atributo.nombre == \"version\") {\r\n                this.version = atributo.valor;\r\n            }\r\n            else if (atributo.nombre == \"encoding\") {\r\n                this.encoding = atributo.valor;\r\n            }\r\n        });\r\n    }\r\n    getCstDotA(idPadre) {\r\n        let texto = \"\";\r\n        texto += Graficas_1.Graficas.getElement(this.idSent, \"TAG_CONFIGURACION\", idPadre);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 1, \"AbreTagConf\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 2, \"<?\", this.idSent + 1);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 3, \"version\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 4, this.version.split(\"\\\"\").join(\"\"), this.idSent + 3);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 5, \"encoding\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 6, this.encoding.split(\"\\\"\").join(\"\"), this.idSent + 5);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 7, \"CierreTagConf\", this.idSent);\r\n        texto += Graficas_1.Graficas.getElement(this.idSent + 8, \"?>\", this.idSent + 7);\r\n        return texto;\r\n    }\r\n}\r\nexports.EtiquetaInicio = EtiquetaInicio;\r\n","/* parser generated by jison 0.4.18 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar XpathT = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,13],$V1=[1,5],$V2=[1,6],$V3=[1,8],$V4=[1,9],$V5=[1,10],$V6=[1,11],$V7=[1,12],$V8=[2,3],$V9=[1,15],$Va=[6,7],$Vb=[2,16,17,18,20,21,59,60,61,62,63,64,66,67,68],$Vc=[2,8],$Vd=[6,7,14,15],$Ve=[1,20],$Vf=[1,21],$Vg=[1,22],$Vh=[6,7,14,15,21,25,29,30,33,34,35,36,37,38,42,43,44],$Vi=[1,50],$Vj=[1,49],$Vk=[1,46],$Vl=[1,45],$Vm=[1,47],$Vn=[1,48],$Vo=[1,52],$Vp=[1,53],$Vq=[1,54],$Vr=[1,55],$Vs=[1,56],$Vt=[2,24],$Vu=[1,67],$Vv=[1,68],$Vw=[25,29,30],$Vx=[25,29,30,33,34,35,36,37,38],$Vy=[2,37],$Vz=[1,80],$VA=[1,78],$VB=[1,79],$VC=[1,81],$VD=[21,25,29,30,33,34,35,36,37,38,42,43,44];\nvar parser = {trace: function trace () { },\nyy: {},\nsymbols_: {\"error\":2,\"inicio\":3,\"xpath\":4,\"inicioaux\":5,\"EOF\":6,\"SEPARADOR\":7,\"simbolo\":8,\"produccion\":9,\"produccionaux\":10,\"aux2\":11,\"aux\":12,\"ComandosLocales\":13,\"SLASH\":14,\"SLASH_DOBLE\":15,\"PUNTO\":16,\"DOBLE_PUNTO\":17,\"ARROBA\":18,\"simboloaux\":19,\"ID\":20,\"MULTIPLICACION\":21,\"atributos\":22,\"COR_IZQUIERDO\":23,\"operacion\":24,\"COR_DERECHO\":25,\"operacion_relacional\":26,\"opaux2\":27,\"opaux\":28,\"AND\":29,\"OR\":30,\"operacion_numerica\":31,\"operacion_relacionalaux\":32,\"IGUAL\":33,\"DIFERENTE\":34,\"MAYOR\":35,\"MENOR\":36,\"MAYOR_IGUAL\":37,\"MENOR_IGUAL\":38,\"valor\":39,\"operacion_numericaaux2\":40,\"operacion_numericaaux\":41,\"MAS\":42,\"MENOS\":43,\"DIVISION\":44,\"ENTERO\":45,\"DECIMAL\":46,\"CADENA\":47,\"localaux\":48,\"LANG\":49,\"TEXTO\":50,\"PAR_IZQUIERDO\":51,\"PAR_DERECHO\":52,\"POSICION\":53,\"ULTIMO\":54,\"NODO\":55,\"local\":56,\"DOBLE_DOSPUNTOS\":57,\"ComandosLocalesaux\":58,\"ANCESTOR\":59,\"SELF\":60,\"ATTRIBUTE\":61,\"CHILD\":62,\"DESCENDANT\":63,\"PRECEDING\":64,\"SIBLING\":65,\"PARENT\":66,\"NAMESPACE\":67,\"FOLLOWING\":68,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",6:\"EOF\",7:\"SEPARADOR\",14:\"SLASH\",15:\"SLASH_DOBLE\",16:\"PUNTO\",17:\"DOBLE_PUNTO\",18:\"ARROBA\",20:\"ID\",21:\"MULTIPLICACION\",23:\"COR_IZQUIERDO\",25:\"COR_DERECHO\",29:\"AND\",30:\"OR\",33:\"IGUAL\",34:\"DIFERENTE\",35:\"MAYOR\",36:\"MENOR\",37:\"MAYOR_IGUAL\",38:\"MENOR_IGUAL\",42:\"MAS\",43:\"MENOS\",44:\"DIVISION\",45:\"ENTERO\",46:\"DECIMAL\",47:\"CADENA\",49:\"LANG\",50:\"TEXTO\",51:\"PAR_IZQUIERDO\",52:\"PAR_DERECHO\",53:\"POSICION\",54:\"ULTIMO\",55:\"NODO\",57:\"DOBLE_DOSPUNTOS\",59:\"ANCESTOR\",60:\"SELF\",61:\"ATTRIBUTE\",62:\"CHILD\",63:\"DESCENDANT\",64:\"PRECEDING\",65:\"SIBLING\",66:\"PARENT\",67:\"NAMESPACE\",68:\"FOLLOWING\"},\nproductions_: [0,[3,3],[5,3],[5,0],[4,2],[4,1],[9,2],[11,3],[11,0],[12,1],[12,1],[8,1],[8,1],[10,1],[10,1],[10,2],[10,1],[10,1],[10,1],[10,2],[10,2],[22,3],[24,2],[27,2],[27,0],[28,2],[28,2],[26,2],[32,2],[32,2],[32,2],[32,2],[32,2],[32,2],[32,0],[31,2],[40,2],[40,0],[41,2],[41,2],[41,2],[41,2],[39,1],[39,1],[39,1],[39,1],[39,2],[39,1],[39,1],[48,1],[48,3],[48,3],[48,3],[48,3],[19,1],[19,1],[19,1],[13,3],[58,1],[58,1],[56,1],[56,5],[56,1],[56,1],[56,1],[56,5],[56,1],[56,3],[56,1],[56,1],[56,1],[56,1],[56,3]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 20:\nconsole.log(\"error sintactico\") ;\r\n        \r\n        \r\n              new ControlError(yytext, TipoSeleccion.ERROR_SINTACTICO, this._$.first_line, this._$.first_column,\"XPatDescendente\")\r\n       \nbreak;\ncase 42: case 43: case 44:\nthis.$ = $$[$0];\nbreak;\ncase 45:\nthis.$ = '\\\"'+$$[$0]+'\\\"';\nbreak;\n}\n},\ntable: [{2:$V0,3:1,4:2,8:3,9:4,10:7,14:$V1,15:$V2,16:$V3,17:$V4,18:$V5,20:$V6,21:$V7},{1:[3]},{5:14,6:$V8,7:$V9},{2:$V0,9:16,10:7,16:$V3,17:$V4,18:$V5,20:$V6,21:$V7},o($Va,[2,5]),o($Vb,[2,11]),o($Vb,[2,12]),o($Va,$Vc,{11:17,8:18,14:$V1,15:$V2}),o($Vd,[2,13]),o($Vd,[2,14]),o($Vd,[2,16],{19:19,20:$Ve,21:$Vf,49:$Vg}),o($Vd,[2,17],{22:23,23:[1,24]}),o($Vd,[2,18]),{7:[1,25]},{6:[1,26]},{2:$V0,4:27,8:3,9:4,10:7,14:$V1,15:$V2,16:$V3,17:$V4,18:$V5,20:$V6,21:$V7},o($Va,[2,4]),o($Va,[2,6]),{2:$V0,10:29,12:28,13:30,16:$V3,17:$V4,18:$V5,20:$V6,21:$V7,56:31,59:[1,32],60:[1,38],61:[1,33],62:[1,34],63:[1,35],64:[1,36],66:[1,37],67:[1,39],68:[1,40]},o($Vd,[2,15]),o($Vh,[2,54]),o($Vh,[2,55]),o($Vh,[2,56]),o($Vd,[2,19]),{16:$Vi,18:$Vj,20:$Vk,24:41,26:42,31:43,39:44,45:$Vl,46:$Vm,47:$Vn,48:51,49:$Vo,50:$Vp,53:$Vq,54:$Vr,55:$Vs},o($Vd,[2,20]),{1:[2,1]},{5:57,6:$V8,7:$V9},o($Va,$Vc,{8:18,11:58,14:$V1,15:$V2}),o($Vd,[2,9]),o($Vd,[2,10]),{57:[1,59]},{43:[1,60],57:[2,60]},{57:[2,62]},{57:[2,63]},{43:[1,61],57:[2,64]},{43:[1,62],57:[2,66]},{57:[2,68]},{57:[2,69]},{57:[2,70]},{43:[1,63],57:[2,71]},{25:[1,64]},{25:$Vt,27:65,28:66,29:$Vu,30:$Vv},o($Vw,[2,34],{32:69,33:[1,70],34:[1,71],35:[1,72],36:[1,73],37:[1,74],38:[1,75]}),o($Vx,$Vy,{40:76,41:77,21:$Vz,42:$VA,43:$VB,44:$VC}),o($Vh,[2,42]),o($Vh,[2,43]),o($Vh,[2,44]),o($Vh,[2,45]),{19:82,20:$Ve,21:$Vf,49:$Vg},o($Vh,[2,47]),o($Vh,[2,48]),o($Vh,[2,49]),{51:[1,83]},{51:[1,84]},{51:[1,85]},{51:[1,86]},{6:[2,2]},o($Va,[2,7]),{16:$Vi,18:$Vj,20:$Vk,21:[1,89],39:88,45:$Vl,46:$Vm,47:$Vn,48:51,49:$Vo,50:$Vp,53:$Vq,54:$Vr,55:$Vs,58:87},{30:[1,90]},{30:[1,91]},{65:[1,92]},{65:[1,93]},o($Vd,[2,21]),o($Vw,[2,22]),{25:$Vt,27:94,28:66,29:$Vu,30:$Vv},{16:$Vi,18:$Vj,20:$Vk,24:95,26:42,31:43,39:44,45:$Vl,46:$Vm,47:$Vn,48:51,49:$Vo,50:$Vp,53:$Vq,54:$Vr,55:$Vs},{16:$Vi,18:$Vj,20:$Vk,24:96,26:42,31:43,39:44,45:$Vl,46:$Vm,47:$Vn,48:51,49:$Vo,50:$Vp,53:$Vq,54:$Vr,55:$Vs},o($Vw,[2,27]),{16:$Vi,18:$Vj,20:$Vk,31:97,39:44,45:$Vl,46:$Vm,47:$Vn,48:51,49:$Vo,50:$Vp,53:$Vq,54:$Vr,55:$Vs},{16:$Vi,18:$Vj,20:$Vk,31:98,39:44,45:$Vl,46:$Vm,47:$Vn,48:51,49:$Vo,50:$Vp,53:$Vq,54:$Vr,55:$Vs},{16:$Vi,18:$Vj,20:$Vk,31:99,39:44,45:$Vl,46:$Vm,47:$Vn,48:51,49:$Vo,50:$Vp,53:$Vq,54:$Vr,55:$Vs},{16:$Vi,18:$Vj,20:$Vk,31:100,39:44,45:$Vl,46:$Vm,47:$Vn,48:51,49:$Vo,50:$Vp,53:$Vq,54:$Vr,55:$Vs},{16:$Vi,18:$Vj,20:$Vk,31:101,39:44,45:$Vl,46:$Vm,47:$Vn,48:51,49:$Vo,50:$Vp,53:$Vq,54:$Vr,55:$Vs},{16:$Vi,18:$Vj,20:$Vk,31:102,39:44,45:$Vl,46:$Vm,47:$Vn,48:51,49:$Vo,50:$Vp,53:$Vq,54:$Vr,55:$Vs},o($VD,[2,35]),o($Vx,$Vy,{41:77,40:103,21:$Vz,42:$VA,43:$VB,44:$VC}),{16:$Vi,18:$Vj,20:$Vk,31:104,39:44,45:$Vl,46:$Vm,47:$Vn,48:51,49:$Vo,50:$Vp,53:$Vq,54:$Vr,55:$Vs},{16:$Vi,18:$Vj,20:$Vk,31:105,39:44,45:$Vl,46:$Vm,47:$Vn,48:51,49:$Vo,50:$Vp,53:$Vq,54:$Vr,55:$Vs},{16:$Vi,18:$Vj,20:$Vk,31:106,39:44,45:$Vl,46:$Vm,47:$Vn,48:51,49:$Vo,50:$Vp,53:$Vq,54:$Vr,55:$Vs},{16:$Vi,18:$Vj,20:$Vk,31:107,39:44,45:$Vl,46:$Vm,47:$Vn,48:51,49:$Vo,50:$Vp,53:$Vq,54:$Vr,55:$Vs},o($Vh,[2,46]),{52:[1,108]},{52:[1,109]},{52:[1,110]},{52:[1,111]},o($Vd,[2,57]),o($Vd,[2,58]),o($Vd,[2,59]),{43:[1,112]},{43:[1,113]},{57:[2,67]},{57:[2,72]},o($Vw,[2,23]),o($Vw,[2,25]),o($Vw,[2,26]),o($Vw,[2,28]),o($Vw,[2,29]),o($Vw,[2,30]),o($Vw,[2,31]),o($Vw,[2,32]),o($Vw,[2,33]),o($VD,[2,36]),o($VD,[2,38]),o($VD,[2,39]),o($VD,[2,40]),o($VD,[2,41]),o($Vh,[2,50]),o($Vh,[2,51]),o($Vh,[2,52]),o($Vh,[2,53]),{60:[1,114]},{60:[1,115]},{57:[2,61]},{57:[2,65]}],\ndefaultActions: {26:[2,1],33:[2,62],34:[2,63],37:[2,68],38:[2,69],39:[2,70],57:[2,2],92:[2,67],93:[2,72],114:[2,61],115:[2,65]},\nparseError: function parseError (str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        var error = new Error(str);\n        error.hash = hash;\n        throw error;\n    }\n},\nparse: function parse (input) {\n    var self = this,\n        stack = [0],\n        tstack = [], // token stack\n        vstack = [null], // semantic value stack\n        lstack = [], // location stack\n        table = this.table,\n        yytext = '',\n        yylineno = 0,\n        yyleng = 0,\n        recovering = 0,\n        TERROR = 2,\n        EOF = 1;\n\n    var args = lstack.slice.call(arguments, 1);\n\n    //this.reductionCount = this.shiftCount = 0;\n\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    // copy state\n    for (var k in this.yy) {\n      if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n        sharedState.yy[k] = this.yy[k];\n      }\n    }\n\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n\n    var ranges = lexer.options && lexer.options.ranges;\n\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n\n    function popStack (n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n\n_token_stack:\n    var lex = function () {\n        var token;\n        token = lexer.lex() || EOF;\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        // retreive state number from top of stack\n        state = stack[stack.length - 1];\n\n        // use default actions if available\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            // read action for current state and first input\n            action = table[state] && table[state][symbol];\n        }\n\n_handle_error:\n        // handle parse error\n        if (typeof action === 'undefined' || !action.length || !action[0]) {\n            var error_rule_depth;\n            var errStr = '';\n\n            // Return the rule stack depth where the nearest error rule can be found.\n            // Return FALSE when no error recovery rule was found.\n            function locateNearestErrorRecoveryRule(state) {\n                var stack_probe = stack.length - 1;\n                var depth = 0;\n\n                // try to recover from error\n                for(;;) {\n                    // check for error recovery rule in this state\n                    if ((TERROR.toString()) in table[state]) {\n                        return depth;\n                    }\n                    if (state === 0 || stack_probe < 2) {\n                        return false; // No suitable error recovery rule available.\n                    }\n                    stack_probe -= 2; // popStack(1): [symbol, action]\n                    state = stack[stack_probe];\n                    ++depth;\n                }\n            }\n\n            if (!recovering) {\n                // first see if there's any chance at hitting an error recovery rule:\n                error_rule_depth = locateNearestErrorRecoveryRule(state);\n\n                // Report error\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push(\"'\"+this.terminals_[p]+\"'\");\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line '+(yylineno+1)+\":\\n\"+lexer.showPosition()+\"\\nExpecting \"+expected.join(', ') + \", got '\" + (this.terminals_[symbol] || symbol)+ \"'\";\n                } else {\n                    errStr = 'Parse error on line '+(yylineno+1)+\": Unexpected \" +\n                                  (symbol == EOF ? \"end of input\" :\n                                              (\"'\"+(this.terminals_[symbol] || symbol)+\"'\"));\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected,\n                    recoverable: (error_rule_depth !== false)\n                });\n            } else if (preErrorSymbol !== EOF) {\n                error_rule_depth = locateNearestErrorRecoveryRule(state);\n            }\n\n            // just recovered from another error\n            if (recovering == 3) {\n                if (symbol === EOF || preErrorSymbol === EOF) {\n                    throw new Error(errStr || 'Parsing halted while starting to recover from another error.');\n                }\n\n                // discard current lookahead and grab another\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                symbol = lex();\n            }\n\n            // try to recover from error\n            if (error_rule_depth === false) {\n                throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');\n            }\n            popStack(error_rule_depth);\n\n            preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token\n            symbol = TERROR;         // insert generic error symbol as new lookahead\n            state = stack[stack.length-1];\n            action = table[state] && table[state][TERROR];\n            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\n        }\n\n        // this shouldn't happen, unless resolve defaults are off\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);\n        }\n\n        switch (action[0]) {\n            case 1: // shift\n                //this.shiftCount++;\n\n                stack.push(symbol);\n                vstack.push(lexer.yytext);\n                lstack.push(lexer.yylloc);\n                stack.push(action[1]); // push state\n                symbol = null;\n                if (!preErrorSymbol) { // normal execution/no error\n                    yyleng = lexer.yyleng;\n                    yytext = lexer.yytext;\n                    yylineno = lexer.yylineno;\n                    yyloc = lexer.yylloc;\n                    if (recovering > 0) {\n                        recovering--;\n                    }\n                } else {\n                    // error just occurred, resume old lookahead f/ before error\n                    symbol = preErrorSymbol;\n                    preErrorSymbol = null;\n                }\n                break;\n\n            case 2:\n                // reduce\n                //this.reductionCount++;\n\n                len = this.productions_[action[1]][1];\n\n                // perform semantic action\n                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1\n                // default location, uses first token for firsts, last for lasts\n                yyval._$ = {\n                    first_line: lstack[lstack.length-(len||1)].first_line,\n                    last_line: lstack[lstack.length-1].last_line,\n                    first_column: lstack[lstack.length-(len||1)].first_column,\n                    last_column: lstack[lstack.length-1].last_column\n                };\n                if (ranges) {\n                  yyval._$.range = [lstack[lstack.length-(len||1)].range[0], lstack[lstack.length-1].range[1]];\n                }\n                r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));\n\n                if (typeof r !== 'undefined') {\n                    return r;\n                }\n\n                // pop off stack\n                if (len) {\n                    stack = stack.slice(0,-1*len*2);\n                    vstack = vstack.slice(0, -1*len);\n                    lstack = lstack.slice(0, -1*len);\n                }\n\n                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)\n                vstack.push(yyval.$);\n                lstack.push(yyval._$);\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[stack[stack.length-2]][stack[stack.length-1]];\n                stack.push(newState);\n                break;\n\n            case 3:\n                // accept\n                return true;\n        }\n\n    }\n\n    return true;\n}};\n    \r\n        const { ControlError } = require('../Xpath/ControlError')\r\n            const { TipoSeleccion } = require('../Xpath/TipoSeleccion')\r\n\r\n//importaciones y demas    \r\n/* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function(match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex () {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin (condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState () {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules () {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState (n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState (condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {\"case-insensitive\":true},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:\nbreak;\ncase 1:return 36\nbreak;\ncase 2:return 35\nbreak;\ncase 3:return 15\nbreak;\ncase 4:return 14\nbreak;\ncase 5:return 33\nbreak;\ncase 6:return 7\nbreak;\ncase 7:return 42\nbreak;\ncase 8:return 43\nbreak;\ncase 9:return 21\nbreak;\ncase 10:return 44\nbreak;\ncase 11:return 34\nbreak;\ncase 12:return 37\nbreak;\ncase 13:return 38\nbreak;\ncase 14:return 29\nbreak;\ncase 15:return 30\nbreak;\ncase 16:return 'MODULAR'\nbreak;\ncase 17:return 18\nbreak;\ncase 18:return 16\nbreak;\ncase 19:return 17 \nbreak;\ncase 20:return 57\nbreak;\ncase 21:return 23\nbreak;\ncase 22:return 25\nbreak;\ncase 23:return 51\nbreak;\ncase 24:return 52\nbreak;\ncase 25:return 59\nbreak;\ncase 26:return 61\nbreak;\ncase 27:return 62\nbreak;\ncase 28:return 63\nbreak;\ncase 29:return 68\nbreak;\ncase 30:return \"NAMESPACE\"\nbreak;\ncase 31:return 66\nbreak;\ncase 32:return 64\nbreak;\ncase 33:return 60\nbreak;\ncase 34:return 'SILBLING'\nbreak;\ncase 35:return 55\nbreak;\ncase 36:return 49   \nbreak;\ncase 37:return 53\nbreak;\ncase 38:return 54\nbreak;\ncase 39:return 50\nbreak;\ncase 40: yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 47; \nbreak;\ncase 41:return 46;\nbreak;\ncase 42:return 45\nbreak;\ncase 43:return 20\nbreak;\ncase 44:return 6;\nbreak;\ncase 45:console.log(yy_.yytext,\"ErroreLexico\");new ControlError(yy_.yytext, TipoSeleccion.ERROR_LEXICO, yy_.yylloc.first_line,yy_.yylloc.first_column,\"XpathDescendente\")\nbreak;\n}\n},\nrules: [/^(?:[\\s]+)/i,/^(?:<)/i,/^(?:>)/i,/^(?:\\/\\/)/i,/^(?:\\/)/i,/^(?:=)/i,/^(?:\\|)/i,/^(?:\\+)/i,/^(?:-)/i,/^(?:\\*)/i,/^(?:div\\b)/i,/^(?:!=)/i,/^(?:>=)/i,/^(?:<=)/i,/^(?:and\\b)/i,/^(?:or\\b)/i,/^(?:mod\\b)/i,/^(?:@)/i,/^(?:\\.)/i,/^(?:\\.\\.)/i,/^(?:::)/i,/^(?:\\[)/i,/^(?:\\])/i,/^(?:\\()/i,/^(?:\\))/i,/^(?:ancestor\\b)/i,/^(?:attribute\\b)/i,/^(?:child\\b)/i,/^(?:descendant\\b)/i,/^(?:following\\b)/i,/^(?:namespace\\b)/i,/^(?:parent\\b)/i,/^(?:preceding\\b)/i,/^(?:self\\b)/i,/^(?:silbling\\b)/i,/^(?:node\\b)/i,/^(?:lang\\b)/i,/^(?:position\\b)/i,/^(?:last\\b)/i,/^(?:text\\b)/i,/^(?:'[^\\']*')/i,/^(?:[0-9]+(\\.[0-9]+)?\\b)/i,/^(?:[0-9]+\\b)/i,/^(?:[a-zA-Z_][a-zA-Z0-9_]*)/i,/^(?:$)/i,/^(?:.)/i],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = XpathT;\nexports.Parser = XpathT.Parser;\nexports.parse = function () { return XpathT.parse.apply(XpathT, arguments); };\nexports.main = function commonjsMain (args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}","import { NgModule } from '@angular/core';\r\nimport { RouterModule, Routes } from '@angular/router';\r\nimport { EditorComponent } from \"./components/editor/editor.component\";\r\nimport { ArbolAstComponent } from 'src/app/components/arbol-ast/arbol-ast.component'\r\nimport { TablaSimbolosComponent } from 'src/app/components/tabla-simbolos/tabla-simbolos.component'\r\nimport { TablaErroresComponent } from 'src/app/components/tabla-errores/tabla-errores.component'\r\n\r\nconst routes: Routes = [\r\n  {\r\n    path: '',\r\n    component: EditorComponent,\r\n    children: [\r\n      {path: 'arbolAst', component: ArbolAstComponent},\r\n      {path: 'tablaDeSimbolos', component:TablaSimbolosComponent},\r\n      {path: 'tablaDeErrores', component: TablaErroresComponent},\r\n    ]\r\n  }\r\n];\r\n\r\n@NgModule({ \r\n  imports: [RouterModule.forRoot(routes)],\r\n  exports: [RouterModule]\r\n})\r\nexport class AppRoutingModule { }\r\n","/* parser generated by jison 0.4.18 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar XpathTA = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,12],$V1=[1,4],$V2=[1,5],$V3=[1,7],$V4=[1,8],$V5=[1,9],$V6=[1,10],$V7=[1,11],$V8=[2,13,14,15,17,18,51,52,53,54,55,56,58,59,60],$V9=[8,11,12],$Va=[1,17],$Vb=[1,18],$Vc=[1,19],$Vd=[8,11,12,18,22,23,24,27,28,29,30,31,32,33,34,35],$Ve=[1,44],$Vf=[1,41],$Vg=[1,40],$Vh=[1,42],$Vi=[1,43],$Vj=[1,45],$Vk=[1,47],$Vl=[1,48],$Vm=[1,49],$Vn=[1,50],$Vo=[1,51],$Vp=[22,23,24],$Vq=[1,68],$Vr=[1,66],$Vs=[1,67],$Vt=[1,69],$Vu=[18,22,23,24,27,28,29,30,31,32,33,34,35],$Vv=[22,23,24,27,28,29,30,31,32,33,34];\nvar parser = {trace: function trace () { },\nyy: {},\nsymbols_: {\"error\":2,\"inicio\":3,\"xpath\":4,\"SEPARADOR\":5,\"simbolo\":6,\"produccion\":7,\"EOF\":8,\"produccionaux\":9,\"ComandosLocales\":10,\"SLASH\":11,\"SLASH_DOBLE\":12,\"PUNTO\":13,\"DOBLE_PUNTO\":14,\"ARROBA\":15,\"simboloaux\":16,\"ID\":17,\"MULTIPLICACION\":18,\"atributos\":19,\"COR_IZQUIERDO\":20,\"operacion\":21,\"COR_DERECHO\":22,\"AND\":23,\"OR\":24,\"operacion_relacional\":25,\"operacion_numerica\":26,\"IGUAL\":27,\"DIFERENTE\":28,\"MAYOR\":29,\"MENOR\":30,\"MAYOR_IGUAL\":31,\"MENOR_IGUAL\":32,\"MAS\":33,\"MENOS\":34,\"DIVISION\":35,\"valor\":36,\"ENTERO\":37,\"DECIMAL\":38,\"CADENA\":39,\"punto\":40,\"localaux\":41,\"LANG\":42,\"TEXTO\":43,\"PAR_IZQUIERDO\":44,\"PAR_DERECHO\":45,\"POSICION\":46,\"ULTIMO\":47,\"NODO\":48,\"local\":49,\"DOBLE_DOSPUNTOS\":50,\"ANCESTOR\":51,\"SELF\":52,\"ATTRIBUTE\":53,\"CHILD\":54,\"DESCENDANT\":55,\"PRECEDING\":56,\"SIBLING\":57,\"PARENT\":58,\"NAMESPACE\":59,\"FOLLOWING\":60,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"SEPARADOR\",8:\"EOF\",11:\"SLASH\",12:\"SLASH_DOBLE\",13:\"PUNTO\",14:\"DOBLE_PUNTO\",15:\"ARROBA\",17:\"ID\",18:\"MULTIPLICACION\",20:\"COR_IZQUIERDO\",22:\"COR_DERECHO\",23:\"AND\",24:\"OR\",27:\"IGUAL\",28:\"DIFERENTE\",29:\"MAYOR\",30:\"MENOR\",31:\"MAYOR_IGUAL\",32:\"MENOR_IGUAL\",33:\"MAS\",34:\"MENOS\",35:\"DIVISION\",37:\"ENTERO\",38:\"DECIMAL\",39:\"CADENA\",40:\"punto\",42:\"LANG\",43:\"TEXTO\",44:\"PAR_IZQUIERDO\",45:\"PAR_DERECHO\",46:\"POSICION\",47:\"ULTIMO\",48:\"NODO\",50:\"DOBLE_DOSPUNTOS\",51:\"ANCESTOR\",52:\"SELF\",53:\"ATTRIBUTE\",54:\"CHILD\",55:\"DESCENDANT\",56:\"PRECEDING\",57:\"SIBLING\",58:\"PARENT\",59:\"NAMESPACE\",60:\"FOLLOWING\"},\nproductions_: [0,[3,3],[3,1],[4,3],[4,2],[7,3],[7,3],[7,1],[6,1],[6,1],[9,1],[9,1],[9,2],[9,1],[9,1],[9,1],[9,2],[9,2],[19,3],[21,3],[21,3],[21,1],[25,3],[25,3],[25,3],[25,3],[25,3],[25,3],[25,1],[26,3],[26,3],[26,3],[26,3],[26,1],[36,1],[36,1],[36,1],[36,1],[36,2],[36,1],[36,1],[41,1],[41,3],[41,3],[41,3],[41,3],[16,1],[16,1],[16,1],[10,3],[10,3],[49,1],[49,5],[49,1],[49,1],[49,1],[49,5],[49,1],[49,3],[49,1],[49,1],[49,1],[49,1],[49,3]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 17:\nconsole.log(\"error sintactico\")\r\n        \r\n                new ControlError(yytext, TipoSeleccion.ERROR_SINTACTICO, this._$.first_line, this._$.first_column,\"XPathAscendente\")\r\n    \r\n        \r\n        \nbreak;\ncase 19:\nthis.$ = $$[$0-2] + \"and\" + $$[$0];\nbreak;\ncase 20:\nthis.$ = $$[$0-2] + \"or\" + $$[$0];\nbreak;\ncase 21: case 28: case 33: case 34: case 35: case 36:\nthis.$ = $$[$0];\nbreak;\ncase 22:\nthis.$ = $$[$0-2] + \"==\" + $$[$0];\nbreak;\ncase 23:\nthis.$ = $$[$0-2] + \"!=\" + $$[$0];\nbreak;\ncase 24:\nthis.$ = $$[$0-2] + \">\" + $$[$0];\nbreak;\ncase 25:\nthis.$ = $$[$0-2] + \"<\" + $$[$0];\nbreak;\ncase 26:\nthis.$ = $$[$0-2] + \">=\" + $$[$0];\nbreak;\ncase 27:\nthis.$ = $$[$0-2] + \"<=\" + $$[$0];\nbreak;\ncase 29:\nthis.$ = $$[$0-2] + \"+\" + $$[$0];\nbreak;\ncase 30:\nthis.$ = $$[$0-2] + \"-\" + $$[$0];\nbreak;\ncase 31:\nthis.$ = $$[$0-2] + \"*\" + $$[$0];\nbreak;\ncase 32:\nthis.$ = $$[$0-2] + \"/\" + $$[$0];\nbreak;\ncase 37:\nthis.$ = '\\\"'+$$[$0]+'\\\"';\nbreak;\n}\n},\ntable: [{2:$V0,4:1,6:2,7:3,9:6,11:$V1,12:$V2,13:$V3,14:$V4,15:$V5,17:$V6,18:$V7},{1:[3]},{2:$V0,7:13,9:6,13:$V3,14:$V4,15:$V5,17:$V6,18:$V7},{6:15,8:[1,14],11:$V1,12:$V2},o($V8,[2,8]),o($V8,[2,9]),o($V9,[2,7]),o($V9,[2,10]),o($V9,[2,11]),o($V9,[2,13],{16:16,17:$Va,18:$Vb,42:$Vc}),o($V9,[2,14],{19:20,20:[1,21]}),o($V9,[2,15]),{5:[1,22]},{6:15,8:[1,23],11:$V1,12:$V2},{1:[2,4]},{2:$V0,9:24,10:25,13:$V3,14:$V4,15:$V5,17:$V6,18:$V7,49:26,51:[1,27],52:[1,33],53:[1,28],54:[1,29],55:[1,30],56:[1,31],58:[1,32],59:[1,34],60:[1,35]},o($V9,[2,12]),o($Vd,[2,46]),o($Vd,[2,47]),o($Vd,[2,48]),o($V9,[2,16]),{15:$Ve,17:$Vf,21:36,25:37,26:38,36:39,37:$Vg,38:$Vh,39:$Vi,40:$Vj,41:46,42:$Vk,43:$Vl,46:$Vm,47:$Vn,48:$Vo},o($V9,[2,17]),{1:[2,3]},o($V9,[2,5]),o($V9,[2,6]),{50:[1,52]},{34:[1,53],50:[2,51]},{50:[2,53]},{50:[2,54]},{34:[1,54],50:[2,55]},{34:[1,55],50:[2,57]},{50:[2,59]},{50:[2,60]},{50:[2,61]},{34:[1,56],50:[2,62]},{22:[1,57],23:[1,58],24:[1,59]},o($Vp,[2,21]),o($Vp,[2,28],{18:$Vq,27:[1,60],28:[1,61],29:[1,62],30:[1,63],31:[1,64],32:[1,65],33:$Vr,34:$Vs,35:$Vt}),o($Vu,[2,33]),o($Vd,[2,34]),o($Vd,[2,35]),o($Vd,[2,36]),o($Vd,[2,37]),{16:70,17:$Va,18:$Vb,42:$Vc},o($Vd,[2,39]),o($Vd,[2,40]),o($Vd,[2,41]),{44:[1,71]},{44:[1,72]},{44:[1,73]},{44:[1,74]},{15:$Ve,17:$Vf,18:[1,76],36:75,37:$Vg,38:$Vh,39:$Vi,40:$Vj,41:46,42:$Vk,43:$Vl,46:$Vm,47:$Vn,48:$Vo},{24:[1,77]},{24:[1,78]},{57:[1,79]},{57:[1,80]},o($V9,[2,18]),{15:$Ve,17:$Vf,21:81,25:37,26:38,36:39,37:$Vg,38:$Vh,39:$Vi,40:$Vj,41:46,42:$Vk,43:$Vl,46:$Vm,47:$Vn,48:$Vo},{15:$Ve,17:$Vf,21:82,25:37,26:38,36:39,37:$Vg,38:$Vh,39:$Vi,40:$Vj,41:46,42:$Vk,43:$Vl,46:$Vm,47:$Vn,48:$Vo},{15:$Ve,17:$Vf,26:83,36:39,37:$Vg,38:$Vh,39:$Vi,40:$Vj,41:46,42:$Vk,43:$Vl,46:$Vm,47:$Vn,48:$Vo},{15:$Ve,17:$Vf,26:84,36:39,37:$Vg,38:$Vh,39:$Vi,40:$Vj,41:46,42:$Vk,43:$Vl,46:$Vm,47:$Vn,48:$Vo},{15:$Ve,17:$Vf,26:85,36:39,37:$Vg,38:$Vh,39:$Vi,40:$Vj,41:46,42:$Vk,43:$Vl,46:$Vm,47:$Vn,48:$Vo},{15:$Ve,17:$Vf,26:86,36:39,37:$Vg,38:$Vh,39:$Vi,40:$Vj,41:46,42:$Vk,43:$Vl,46:$Vm,47:$Vn,48:$Vo},{15:$Ve,17:$Vf,26:87,36:39,37:$Vg,38:$Vh,39:$Vi,40:$Vj,41:46,42:$Vk,43:$Vl,46:$Vm,47:$Vn,48:$Vo},{15:$Ve,17:$Vf,26:88,36:39,37:$Vg,38:$Vh,39:$Vi,40:$Vj,41:46,42:$Vk,43:$Vl,46:$Vm,47:$Vn,48:$Vo},{15:$Ve,17:$Vf,26:89,36:39,37:$Vg,38:$Vh,39:$Vi,40:$Vj,41:46,42:$Vk,43:$Vl,46:$Vm,47:$Vn,48:$Vo},{15:$Ve,17:$Vf,26:90,36:39,37:$Vg,38:$Vh,39:$Vi,40:$Vj,41:46,42:$Vk,43:$Vl,46:$Vm,47:$Vn,48:$Vo},{15:$Ve,17:$Vf,26:91,36:39,37:$Vg,38:$Vh,39:$Vi,40:$Vj,41:46,42:$Vk,43:$Vl,46:$Vm,47:$Vn,48:$Vo},{15:$Ve,17:$Vf,26:92,36:39,37:$Vg,38:$Vh,39:$Vi,40:$Vj,41:46,42:$Vk,43:$Vl,46:$Vm,47:$Vn,48:$Vo},o($Vd,[2,38]),{45:[1,93]},{45:[1,94]},{45:[1,95]},{45:[1,96]},o($V9,[2,49]),o($V9,[2,50]),{34:[1,97]},{34:[1,98]},{50:[2,58]},{50:[2,63]},o($Vp,[2,19]),o($Vp,[2,20]),o($Vp,[2,22],{18:$Vq,33:$Vr,34:$Vs,35:$Vt}),o($Vp,[2,23],{18:$Vq,33:$Vr,34:$Vs,35:$Vt}),o($Vp,[2,24],{18:$Vq,33:$Vr,34:$Vs,35:$Vt}),o($Vp,[2,25],{18:$Vq,33:$Vr,34:$Vs,35:$Vt}),o($Vp,[2,26],{18:$Vq,33:$Vr,34:$Vs,35:$Vt}),o($Vp,[2,27],{18:$Vq,33:$Vr,34:$Vs,35:$Vt}),o($Vv,[2,29],{18:$Vq,35:$Vt}),o($Vv,[2,30],{18:$Vq,35:$Vt}),o($Vu,[2,31]),o($Vu,[2,32]),o($Vd,[2,42]),o($Vd,[2,43]),o($Vd,[2,44]),o($Vd,[2,45]),{52:[1,99]},{52:[1,100]},{50:[2,52]},{50:[2,56]}],\ndefaultActions: {14:[2,4],23:[2,3],28:[2,53],29:[2,54],32:[2,59],33:[2,60],34:[2,61],79:[2,58],80:[2,63],99:[2,52],100:[2,56]},\nparseError: function parseError (str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        var error = new Error(str);\n        error.hash = hash;\n        throw error;\n    }\n},\nparse: function parse (input) {\n    var self = this,\n        stack = [0],\n        tstack = [], // token stack\n        vstack = [null], // semantic value stack\n        lstack = [], // location stack\n        table = this.table,\n        yytext = '',\n        yylineno = 0,\n        yyleng = 0,\n        recovering = 0,\n        TERROR = 2,\n        EOF = 1;\n\n    var args = lstack.slice.call(arguments, 1);\n\n    //this.reductionCount = this.shiftCount = 0;\n\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    // copy state\n    for (var k in this.yy) {\n      if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n        sharedState.yy[k] = this.yy[k];\n      }\n    }\n\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n\n    var ranges = lexer.options && lexer.options.ranges;\n\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n\n    function popStack (n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n\n_token_stack:\n    var lex = function () {\n        var token;\n        token = lexer.lex() || EOF;\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        // retreive state number from top of stack\n        state = stack[stack.length - 1];\n\n        // use default actions if available\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            // read action for current state and first input\n            action = table[state] && table[state][symbol];\n        }\n\n_handle_error:\n        // handle parse error\n        if (typeof action === 'undefined' || !action.length || !action[0]) {\n            var error_rule_depth;\n            var errStr = '';\n\n            // Return the rule stack depth where the nearest error rule can be found.\n            // Return FALSE when no error recovery rule was found.\n            function locateNearestErrorRecoveryRule(state) {\n                var stack_probe = stack.length - 1;\n                var depth = 0;\n\n                // try to recover from error\n                for(;;) {\n                    // check for error recovery rule in this state\n                    if ((TERROR.toString()) in table[state]) {\n                        return depth;\n                    }\n                    if (state === 0 || stack_probe < 2) {\n                        return false; // No suitable error recovery rule available.\n                    }\n                    stack_probe -= 2; // popStack(1): [symbol, action]\n                    state = stack[stack_probe];\n                    ++depth;\n                }\n            }\n\n            if (!recovering) {\n                // first see if there's any chance at hitting an error recovery rule:\n                error_rule_depth = locateNearestErrorRecoveryRule(state);\n\n                // Report error\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push(\"'\"+this.terminals_[p]+\"'\");\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line '+(yylineno+1)+\":\\n\"+lexer.showPosition()+\"\\nExpecting \"+expected.join(', ') + \", got '\" + (this.terminals_[symbol] || symbol)+ \"'\";\n                } else {\n                    errStr = 'Parse error on line '+(yylineno+1)+\": Unexpected \" +\n                                  (symbol == EOF ? \"end of input\" :\n                                              (\"'\"+(this.terminals_[symbol] || symbol)+\"'\"));\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected,\n                    recoverable: (error_rule_depth !== false)\n                });\n            } else if (preErrorSymbol !== EOF) {\n                error_rule_depth = locateNearestErrorRecoveryRule(state);\n            }\n\n            // just recovered from another error\n            if (recovering == 3) {\n                if (symbol === EOF || preErrorSymbol === EOF) {\n                    throw new Error(errStr || 'Parsing halted while starting to recover from another error.');\n                }\n\n                // discard current lookahead and grab another\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                symbol = lex();\n            }\n\n            // try to recover from error\n            if (error_rule_depth === false) {\n                throw new Error(errStr || 'Parsing halted. No suitable error recovery rule available.');\n            }\n            popStack(error_rule_depth);\n\n            preErrorSymbol = (symbol == TERROR ? null : symbol); // save the lookahead token\n            symbol = TERROR;         // insert generic error symbol as new lookahead\n            state = stack[stack.length-1];\n            action = table[state] && table[state][TERROR];\n            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\n        }\n\n        // this shouldn't happen, unless resolve defaults are off\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);\n        }\n\n        switch (action[0]) {\n            case 1: // shift\n                //this.shiftCount++;\n\n                stack.push(symbol);\n                vstack.push(lexer.yytext);\n                lstack.push(lexer.yylloc);\n                stack.push(action[1]); // push state\n                symbol = null;\n                if (!preErrorSymbol) { // normal execution/no error\n                    yyleng = lexer.yyleng;\n                    yytext = lexer.yytext;\n                    yylineno = lexer.yylineno;\n                    yyloc = lexer.yylloc;\n                    if (recovering > 0) {\n                        recovering--;\n                    }\n                } else {\n                    // error just occurred, resume old lookahead f/ before error\n                    symbol = preErrorSymbol;\n                    preErrorSymbol = null;\n                }\n                break;\n\n            case 2:\n                // reduce\n                //this.reductionCount++;\n\n                len = this.productions_[action[1]][1];\n\n                // perform semantic action\n                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1\n                // default location, uses first token for firsts, last for lasts\n                yyval._$ = {\n                    first_line: lstack[lstack.length-(len||1)].first_line,\n                    last_line: lstack[lstack.length-1].last_line,\n                    first_column: lstack[lstack.length-(len||1)].first_column,\n                    last_column: lstack[lstack.length-1].last_column\n                };\n                if (ranges) {\n                  yyval._$.range = [lstack[lstack.length-(len||1)].range[0], lstack[lstack.length-1].range[1]];\n                }\n                r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));\n\n                if (typeof r !== 'undefined') {\n                    return r;\n                }\n\n                // pop off stack\n                if (len) {\n                    stack = stack.slice(0,-1*len*2);\n                    vstack = vstack.slice(0, -1*len);\n                    lstack = lstack.slice(0, -1*len);\n                }\n\n                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)\n                vstack.push(yyval.$);\n                lstack.push(yyval._$);\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[stack[stack.length-2]][stack[stack.length-1]];\n                stack.push(newState);\n                break;\n\n            case 3:\n                // accept\n                return true;\n        }\n\n    }\n\n    return true;\n}};\n    \r\n        const { ControlError } = require('../Xpath/ControlError')\r\n            const { TipoSeleccion } = require('../Xpath/TipoSeleccion')\r\n\r\n//importaciones y demas    \r\n/* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function(match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex () {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin (condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState () {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules () {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState (n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState (condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {\"case-insensitive\":true},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:\nbreak;\ncase 1:return 30\nbreak;\ncase 2:return 29\nbreak;\ncase 3:return 12\nbreak;\ncase 4:return 11\nbreak;\ncase 5:return 27\nbreak;\ncase 6:return 5\nbreak;\ncase 7:return 33\nbreak;\ncase 8:return 34\nbreak;\ncase 9:return 18\nbreak;\ncase 10:return 35\nbreak;\ncase 11:return 28\nbreak;\ncase 12:return 31\nbreak;\ncase 13:return 32\nbreak;\ncase 14:return 23\nbreak;\ncase 15:return 24\nbreak;\ncase 16:return 'MODULAR'\nbreak;\ncase 17:return 15\nbreak;\ncase 18:return 13\nbreak;\ncase 19:return 14 \nbreak;\ncase 20:return 50\nbreak;\ncase 21:return 20\nbreak;\ncase 22:return 22\nbreak;\ncase 23:return 44\nbreak;\ncase 24:return 45\nbreak;\ncase 25:return 51\nbreak;\ncase 26:return 53\nbreak;\ncase 27:return 54\nbreak;\ncase 28:return 55\nbreak;\ncase 29:return 60\nbreak;\ncase 30:return \"NAMESPACE\"\nbreak;\ncase 31:return 58\nbreak;\ncase 32:return 56\nbreak;\ncase 33:return 52\nbreak;\ncase 34:return 'SILBLING'\nbreak;\ncase 35:return 48\nbreak;\ncase 36:return 42   \nbreak;\ncase 37:return 46\nbreak;\ncase 38:return 47\nbreak;\ncase 39:return 43\nbreak;\ncase 40: yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 39; \nbreak;\ncase 41:return 38;\nbreak;\ncase 42:return 37\nbreak;\ncase 43:return 17\nbreak;\ncase 44:return 8;\nbreak;\ncase 45:console.log(yy_.yytext,\"ErroreLexico\");new ControlError(yy_.yytext, TipoSeleccion.ERROR_LEXICO, yy_.yylloc.first_line,yy_.yylloc.first_column,\"XpathAscendente\") \nbreak;\n}\n},\nrules: [/^(?:[\\s]+)/i,/^(?:<)/i,/^(?:>)/i,/^(?:\\/\\/)/i,/^(?:\\/)/i,/^(?:=)/i,/^(?:\\|)/i,/^(?:\\+)/i,/^(?:-)/i,/^(?:\\*)/i,/^(?:div\\b)/i,/^(?:!=)/i,/^(?:>=)/i,/^(?:<=)/i,/^(?:and\\b)/i,/^(?:or\\b)/i,/^(?:mod\\b)/i,/^(?:@)/i,/^(?:\\.)/i,/^(?:\\.\\.)/i,/^(?:::)/i,/^(?:\\[)/i,/^(?:\\])/i,/^(?:\\()/i,/^(?:\\))/i,/^(?:ancestor\\b)/i,/^(?:attribute\\b)/i,/^(?:child\\b)/i,/^(?:descendant\\b)/i,/^(?:following\\b)/i,/^(?:namespace\\b)/i,/^(?:parent\\b)/i,/^(?:preceding\\b)/i,/^(?:self\\b)/i,/^(?:silbling\\b)/i,/^(?:node\\b)/i,/^(?:lang\\b)/i,/^(?:position\\b)/i,/^(?:last\\b)/i,/^(?:text\\b)/i,/^(?:'[^\\']*')/i,/^(?:[0-9]+(\\.[0-9]+)?\\b)/i,/^(?:[0-9]+\\b)/i,/^(?:[a-zA-Z_][a-zA-Z0-9_]*)/i,/^(?:$)/i,/^(?:.)/i],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = XpathTA;\nexports.Parser = XpathTA.Parser;\nexports.parse = function () { return XpathTA.parse.apply(XpathTA, arguments); };\nexports.main = function commonjsMain (args) {\n    if (!args[1]) {\n        console.log('Usage: '+args[0]+' FILE');\n        process.exit(1);\n    }\n    var source = require('fs').readFileSync(require('path').normalize(args[1]), \"utf8\");\n    return exports.parser.parse(source);\n};\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(process.argv.slice(1));\n}\n}","import { enableProdMode } from '@angular/core';\r\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\r\n\r\nimport { AppModule } from './app/app.module';\r\nimport { environment } from './environments/environment';\r\n\r\nif (environment.production) {\r\n  enableProdMode();\r\n}\r\n\r\nplatformBrowserDynamic().bootstrapModule(AppModule)\r\n  .catch(err => console.error(err));\r\n","function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nmodule.exports = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = \"zn8P\";"],"sourceRoot":"webpack:///"}